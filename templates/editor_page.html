{% extends "base.html" %}
{% block title %}Editor LaTeX - DocCollab{% endblock %}
{% block content %}
<!-- Barra de ferramentas do editor -->
<div class="editor-toolbar">
  <div class="toolbar-left">
    <a href="{{ url_for('dashboard') }}" class="btn-tool btn-back" title="Voltar ao Dashboard">
      <i class="fas fa-arrow-left"></i>
      <span>Voltar</span>
    </a>
    <div class="divider"></div>
    <button class="btn-tool" onclick="saveDocument()" title="{{ _('Save') }} (Ctrl+S)">
      <i class="fas fa-save"></i>
      <span>{{ _('Save') }}</span>
    </button>
    <button class="btn-tool" onclick="newDocument()" title="{{ _('New') }} (Ctrl+N)">
      <i class="fas fa-file-plus"></i>
      <span>{{ _('New') }}</span>
    </button>
    <button class="btn-tool" onclick="openDocument()" title="{{ _('Open') }} (Ctrl+O)">
      <i class="fas fa-folder-open"></i>
      <span>{{ _('Open') }}</span>
    </button>
    <div class="divider"></div>
    <button class="btn-tool" onclick="uploadImage()" title="Upload Imagem" style="background: #28a745;">
      <i class="fas fa-image"></i>
      <span>Imagem</span>
    </button>
    <div class="divider"></div>
    <button class="btn-tool" onclick="undoAction()" title="Desfazer (Ctrl+Z)">
      <i class="fas fa-undo"></i>
    </button>
    <button class="btn-tool" onclick="redoAction()" title="Refazer (Ctrl+Y)">
      <i class="fas fa-redo"></i>
    </button>
  </div>
  
  <div class="toolbar-center">
    <div class="file-info">
      <i class="fas fa-file-alt"></i>
      <span id="fileName">Sem título</span>
      <span class="file-status" id="fileStatus">●</span>
    </div>
  </div>
  
  <div class="toolbar-right">
    <button class="btn-compile" onclick="compileDocument()" title="{{ _('Compile') }} (F5)">
      <i class="fas fa-play"></i>
      <span>{{ _('Compile') }}</span>
    </button>
    <button class="btn-tool" onclick="previewDocument()" title="Visualizar (F6)">
      <i class="fas fa-eye"></i>
    </button>
  </div>
</div>

<!-- Editor principal -->
<div class="editor-container">
  <div class="editor-sidebar">
    <div class="sidebar-section">
      <h4><i class="fas fa-code"></i> Snippets</h4>
      <div class="snippet-list">
        <div class="snippet-item" onclick="insertSnippet('section')">
          <i class="fas fa-heading"></i>
          <span>{{ _('Section') }}</span>
        </div>
        <div class="snippet-item" onclick="insertSnippet('equation')">
          <i class="fas fa-square-root-alt"></i>
          <span>{{ _('Equation') }}</span>
        </div>
        <div class="snippet-item" onclick="insertSnippet('table')">
          <i class="fas fa-table"></i>
          <span>{{ _('Table') }}</span>
        </div>
        <div class="snippet-item" onclick="insertSnippet('list')">
          <i class="fas fa-list"></i>
          <span>{{ _('List') }}</span>
        </div>
        <div class="snippet-item" onclick="insertSnippet('figure')">
          <i class="fas fa-image"></i>
          <span>{{ _('Figure') }}</span>
        </div>
      </div>
    </div>
    
  </div>
  
  <div class="editor-main">
    <div class="editor-tabs">
      <div class="tab active" data-file="main.tex">
        <i class="fas fa-file-alt"></i>
        <span>main.tex</span>
        <button class="tab-close" onclick="closeTab('main.tex')">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <!-- Barra de formatação ao lado da aba -->
      <div class="format-toolbar">
        <button class="format-btn" onclick="formatText('bold')" title="Negrito (Ctrl+B)">
          <i class="fas fa-bold"></i>
        </button>
        <button class="format-btn" onclick="formatText('italic')" title="Itálico (Ctrl+I)">
          <i class="fas fa-italic"></i>
        </button>
        <button class="format-btn" onclick="formatText('underline')" title="Sublinhado (Ctrl+U)">
          <i class="fas fa-underline"></i>
        </button>
        <div class="format-divider"></div>
        <button class="format-btn" onclick="insertSnippet('section')" title="Inserir Seção">
          <i class="fas fa-heading"></i>
        </button>
        <button class="format-btn" onclick="insertSnippet('equation')" title="Inserir Equação">
          <i class="fas fa-square-root-alt"></i>
        </button>
        <button class="format-btn" onclick="insertSnippet('list')" title="Inserir Lista">
          <i class="fas fa-list"></i>
        </button>
      </div>
    </div>
    
    <div class="editor-wrapper">
      <div class="line-numbers" id="lineNumbers"></div>
      <div class="editor-content">
        <div class="line-highlight-background" id="lineHighlightBg"></div>
        <textarea 
          id="latexEditor" 
          class="latex-editor"
          autofocus
          spellcheck="false"
          placeholder="Clique em 'New' para criar um novo documento ou 'Open' para abrir um arquivo existente..."
        ></textarea>
      </div>
    </div>
    
    <div class="editor-status">
      <div class="status-left">
        <span id="cursorPosition">Linha 1, Coluna 1</span>
        <span class="divider">|</span>
        <span id="documentLength">0 caracteres</span>
        <span class="divider">|</span>
        <span id="wordCount">0 palavras</span>
      </div>
      <div class="status-right">
        <span id="encoding">UTF-8</span>
        <span class="divider">|</span>
        <span id="language">LaTeX</span>
      </div>
    </div>
  </div>
</div>

<style>
/* Editor LaTeX Profissional */
.editor-toolbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 2rem;
  background: #f8f9fa;
  color: #495057;
  border-bottom: 1px solid #dee2e6;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin-top: 20px;
  min-height: 50px;
  margin-left: auto;
  margin-right: auto;
  max-width: 1200px;
  width: 100%;
}

.toolbar-left, .toolbar-right {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.toolbar-center {
  flex: 1;
  display: flex;
  justify-content: center;
}

.btn-tool {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: #6c757d;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.9rem;
  height: 36px;
}

.btn-tool:hover {
  background: #5a6268;
  transform: translateY(-1px);
}

.btn-compile {
  background: #007bff;
  font-weight: 600;
  height: 36px;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.9rem;
}

.btn-compile:hover {
  background: #0056b3;
}

.divider {
  width: 1px;
  height: 24px;
  background: #dee2e6;
  margin: 0 0.5rem;
}

.file-info {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: #e9ecef;
  border-radius: 4px;
  font-size: 0.9rem;
  color: #495057;
}

.file-status {
  color: #68d391;
  font-size: 1.2rem;
}

.editor-container {
  display: flex;
  height: calc(100vh - 140px);
  background: #ffffff;
  margin-left: auto;
  margin-right: auto;
  max-width: 1200px;
  width: 100%;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  overflow: hidden;
}

.editor-sidebar {
  width: 250px;
  background: #f8f9fa;
  border-right: 1px solid #dee2e6;
  padding: 1rem;
  overflow-y: auto;
}

.sidebar-section {
  margin-bottom: 1.5rem;
}

.sidebar-section h4 {
  color: #495057;
  font-size: 0.9rem;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.snippet-list {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.snippet-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem;
  color: #6c757d;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
  font-size: 0.85rem;
}

.snippet-item:hover {
  background: #e9ecef;
  color: #495057;
}


.file-item .file-name {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.file-item .file-actions {
  display: none;
  gap: 0.25rem;
}

.file-item:hover .file-actions {
  display: flex;
}

.file-action-btn {
  background: none;
  border: none;
  padding: 0.25rem;
  cursor: pointer;
  color: inherit;
  opacity: 0.7;
  transition: opacity 0.2s;
}

.file-action-btn:hover {
  opacity: 1;
}

.file-separator {
  padding: 0.5rem;
  font-size: 0.75rem;
  font-weight: 600;
  color: #6c757d;
  text-transform: uppercase;
  border-top: 1px solid #dee2e6;
  margin-top: 0.5rem;
}

/* Botões de Ação na Sidebar */
.btn-new-file, .btn-new-folder {
  background: #28a745;
  color: white;
  border: none;
  padding: 0.25rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  font-size: 0.75rem;
  margin-left: 0.25rem;
  transition: all 0.2s;
}

.btn-new-file:first-of-type {
  margin-left: auto;
}

.btn-new-folder {
  background: #17a2b8;
}

.btn-new-file:hover {
  background: #218838;
  transform: scale(1.05);
}

.btn-new-folder:hover {
  background: #138496;
  transform: scale(1.05);
}

.files-loading {
  text-align: center;
  padding: 2rem 1rem;
  color: #6c757d;
}

.files-loading i {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}


.sidebar-section h4 {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}




/* Drag and Drop Zone */
.drop-zone {
  border: 2px dashed #dee2e6;
  border-radius: 4px;
  padding: 2rem;
  text-align: center;
  color: #6c757d;
  transition: all 0.2s;
}

.drop-zone.drag-over {
  border-color: #007bff;
  background: #e7f3ff;
  color: #007bff;
}

.drop-zone i {
  font-size: 2rem;
  margin-bottom: 0.5rem;
}

.editor-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #ffffff;
}

.editor-tabs {
  display: flex;
  background: #f8f9fa;
  border-bottom: 1px solid #dee2e6;
  padding: 0 1rem;
  align-items: center;
  justify-content: space-between;
}

.tab {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1rem;
  background: #f8f9fa;
  color: #6c757d;
  cursor: pointer;
  transition: all 0.2s ease;
  border-right: 1px solid #dee2e6;
  font-size: 0.9rem;
}

.tab.active {
  background: #ffffff;
  color: #495057;
  border-bottom: 2px solid #007bff;
}

.tab:hover {
  background: #e9ecef;
  color: #495057;
}

.tab-close {
  background: none;
  border: none;
  color: #6c757d;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: all 0.2s ease;
  margin-left: 0.5rem;
}

.tab-close:hover {
  background: #e9ecef;
  color: #495057;
}

/* Barra de formatação */
.format-toolbar {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  padding: 0.5rem 0;
}

.format-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  background: #e9ecef;
  color: #495057;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 0.9rem;
}

.format-btn:hover {
  background: #007bff;
  color: white;
  transform: translateY(-1px);
}

.format-btn:active {
  transform: translateY(0);
}

.format-divider {
  width: 1px;
  height: 20px;
  background: #dee2e6;
  margin: 0 0.5rem;
}

.editor-wrapper {
  flex: 1;
  display: flex;
  position: relative;
  overflow: hidden;
}

.line-numbers {
  width: 50px;
  background: #f8f9fa;
  color: #6c757d;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.5;
  padding: 1rem 0.5rem;
  text-align: right;
  user-select: none;
  border-right: 1px solid #dee2e6;
  overflow-y: hidden;
  overflow-x: hidden;
}

.line-number {
  height: 1.5em;
  line-height: 1.5;
}

.editor-content {
  flex: 1;
  position: relative;
  background: #ffffff;
}

.line-highlight-background {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 0;
  padding: 1rem;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
  font-size: 14px;
  line-height: 1.5;
  overflow: hidden;
  white-space: pre;
}

.latex-editor {
  width: 100%;
  height: 100%;
  border: none;
  outline: none;
  padding: 1rem;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
  font-size: 14px;
  line-height: 1.5;
  background: transparent;
  color: #495057;
  resize: none;
  tab-size: 2;
  overflow-y: auto;
  position: relative;
  z-index: 1;
}

.latex-editor:focus {
  box-shadow: none;
}

.editor-status {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 1rem;
  background: #f8f9fa;
  color: #6c757d;
  font-size: 0.8rem;
  border-top: 1px solid #dee2e6;
}

.status-left, .status-right {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.status-left .divider, .status-right .divider {
  color: #dee2e6;
}

/* Container principal para alinhamento */
.main-content {
  padding: 0 2rem;
  margin: 0 auto;
  width: 100%;
  max-width: 1200px;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Responsive */
@media (max-width: 1200px) {
  .editor-toolbar,
  .editor-container,
  .main-content {
    max-width: 100%;
    margin-left: 1rem;
    margin-right: 1rem;
  }
}

@media (max-width: 768px) {
  .editor-sidebar {
    width: 200px;
  }
  
  .editor-toolbar {
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    margin-left: 0.5rem;
    margin-right: 0.5rem;
  }
  
  .editor-container {
    margin-left: 0.5rem;
    margin-right: 0.5rem;
  }
  
  .main-content {
    padding: 0 0.5rem;
  }
  
  .toolbar-left, .toolbar-right {
    flex-wrap: wrap;
  }
  
  .btn-tool {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
    height: 32px;
  }
  
  .btn-tool span {
    display: none;
  }
  
  .format-toolbar {
    gap: 0.1rem;
    padding: 0.25rem 0;
  }
  
  .format-btn {
    width: 28px;
    height: 28px;
    font-size: 0.8rem;
  }
}

@media (max-width: 480px) {
  .editor-sidebar {
    display: none;
  }
  
  .editor-toolbar {
    padding: 0.25rem 0.5rem;
    margin-left: 0.25rem;
    margin-right: 0.25rem;
  }
  
  .editor-container {
    margin-left: 0.25rem;
    margin-right: 0.25rem;
  }
  
  .main-content {
    padding: 0 0.25rem;
  }
  
  .btn-tool {
    padding: 0.3rem 0.6rem;
    font-size: 0.75rem;
    height: 28px;
  }
}

/* ========================================
   LINTER - Destaque de Erros no Editor
   ======================================== */
.lint-error-marker {
  position: absolute;
  left: 0;
  width: 100%;
  background: rgba(255, 0, 0, 0.1);
  border-left: 3px solid #dc3545;
  pointer-events: none;
  z-index: 1;
}

.lint-warning-marker {
  position: absolute;
  left: 0;
  width: 100%;
  background: rgba(255, 193, 7, 0.1);
  border-left: 3px solid #ffc107;
  pointer-events: none;
  z-index: 1;
}

.lint-icon {
  position: absolute;
  left: -25px;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  cursor: pointer;
  z-index: 10;
}

.lint-icon-error {
  color: #dc3545;
}

.lint-icon-warning {
  color: #ffc107;
}

.lint-tooltip {
  position: absolute;
  background: #2c3e50;
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  max-width: 300px;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  pointer-events: none;
  white-space: pre-wrap;
}

.lint-tooltip::before {
  content: '';
  position: absolute;
  left: -6px;
  top: 50%;
  transform: translateY(-50%);
  border: 6px solid transparent;
  border-right-color: #2c3e50;
}

.lint-tooltip-title {
  font-weight: bold;
  margin-bottom: 4px;
}

.lint-tooltip-suggestion {
  color: #a8dadc;
  font-style: italic;
  margin-top: 4px;
}
</style>

<script>
// Editor LaTeX Profissional com pdflatex
class LaTeXEditor {
  constructor() {
    this.editor = document.getElementById('latexEditor');
    this.lineNumbers = document.getElementById('lineNumbers');
    this.cursorPosition = document.getElementById('cursorPosition');
    this.documentLength = document.getElementById('documentLength');
    this.wordCount = document.getElementById('wordCount');
    this.fileStatus = document.getElementById('fileStatus');
    this.fileName = document.getElementById('fileName');
    
    this.history = [];
    this.historyIndex = -1;
    this.isModified = false;
    
    // Gerenciamento de arquivos LOCAL (pasta Arquivos do usuário)
    this.workingDirectory = null;
    this.currentFileHandle = null;
    this.projectFiles = [];
    
    this.init();
  }
  
  init() {
    this.setupEventListeners();
    this.updateLineNumbers();
    this.updateStatus();
    this.updateFileStatus();
    this.editor.focus();
    this.setupKeyboardShortcuts();
    
    // Marcar como NÃO modificado no início (documento padrão)
    this.isModified = false;
    this.fileStatus.textContent = '●';
    this.fileStatus.style.color = '#68d391';
    
    // Configurar drag-and-drop de imagens
    this.setupImageDragDrop();
    
    // Solicitar acesso à pasta "Arquivos" automaticamente
    this.requestWorkingDirectory();
  }
  
  // ============================================================================
  // GERENCIAMENTO DE ARQUIVOS LOCAL (PASTA ARQUIVOS)
  // ============================================================================
  
  async requestWorkingDirectory() {
    // Sistema funciona via upload/download - não precisa de permissões especiais
    console.log('[FileSystem] Usando modo compatível (upload/download)');
    return;
    
    try {
      // Código legado removido
      const dirHandle = null;
      
      this.workingDirectory = dirHandle;
      this.showNotification('✓ Pasta selecionada: ' + dirHandle.name, 'success');
      
      // Atualizar lista de arquivos
      await this.updateFilesList();
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Erro ao selecionar pasta:', err);
        this.showNotification('❌ Erro ao selecionar pasta!', 'error');
      }
    }
  }
  
  async updateFilesList() {
    const filesList = document.getElementById('filesList');
    if (!filesList) return;
    
    if (!this.workingDirectory) {
      filesList.innerHTML = `
        <div class="files-empty">
          <i class="fas fa-folder-open"></i>
          <p>Selecione a pasta "Arquivos"</p>
          <small>Clique no botão + para começar</small>
        </div>
      `;
      return;
    }
    
    try {
      const files = [];
      for await (const entry of this.workingDirectory.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.tex')) {
          files.push(entry);
        }
      }
      
      if (files.length === 0) {
        filesList.innerHTML = `
          <div class="files-empty">
            <i class="fas fa-folder-open"></i>
            <p>Nenhum arquivo .tex</p>
            <small>Crie um novo documento!</small>
          </div>
        `;
        return;
      }
      
      // Ordenar por nome
      files.sort((a, b) => a.name.localeCompare(b.name));
      
      // Renderizar lista
      filesList.innerHTML = files.map(fileHandle => `
        <div class="file-item ${this.currentFileHandle?.name === fileHandle.name ? 'active' : ''}" 
             onclick="window.latexEditor.openFileFromList('${fileHandle.name}')"
             title="${fileHandle.name}">
          <i class="fas fa-file-alt"></i>
          <span class="file-name">${fileHandle.name}</span>
        </div>
      `).join('');
      
    } catch (err) {
      console.error('Erro ao listar arquivos:', err);
      filesList.innerHTML = `
        <div class="files-empty">
          <i class="fas fa-exclamation-triangle"></i>
          <p>Erro ao listar arquivos</p>
          <small>${err.message}</small>
        </div>
      `;
    }
  }
  
  async openFileFromList(fileName) {
    if (!this.workingDirectory) {
      this.showNotification('❌ Pasta não selecionada!', 'error');
      return;
    }
    
    try {
      const fileHandle = await this.workingDirectory.getFileHandle(fileName);
      this.currentFileHandle = fileHandle;
      
      const file = await fileHandle.getFile();
      const content = await file.text();
      
      this.editor.value = content;
      this.fileName.textContent = fileHandle.name;
      this.updateLineNumbers();
      this.updateStatus();
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Arquivo aberto: ' + fileName, 'success');
      
      // Atualizar lista
      await this.updateFilesList();
    } catch (err) {
      console.error('Erro ao abrir arquivo:', err);
      this.showNotification('❌ Erro ao abrir arquivo!', 'error');
    }
  }
  
  async saveDocument() {
    if (!this.currentFileHandle) {
      // Se não tem arquivo aberto, fazer "Salvar Como"
      return this.saveAsDocument();
    }
    
    try {
      const writable = await this.currentFileHandle.createWritable();
      await writable.write(this.editor.value);
      await writable.close();
      
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Documento salvo!', 'success');
      
      await this.updateFilesList();
    } catch (err) {
      console.error('Erro ao salvar:', err);
      this.showNotification('❌ Erro ao salvar documento!', 'error');
    }
  }
  
  async saveAsDocument() {
    if (!this.workingDirectory) {
      this.showNotification('❌ Selecione a pasta "Arquivos" primeiro!', 'error');
      return;
    }
    
    const fileName = prompt('Nome do arquivo:', this.fileName.textContent || 'documento.tex');
    if (!fileName) return;
    
    const finalFileName = fileName.endsWith('.tex') ? fileName : fileName + '.tex';
    
    try {
      const fileHandle = await this.workingDirectory.getFileHandle(finalFileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(this.editor.value);
      await writable.close();
      
      this.currentFileHandle = fileHandle;
      this.fileName.textContent = finalFileName;
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Documento salvo como: ' + finalFileName, 'success');
      
      await this.updateFilesList();
    } catch (err) {
      console.error('Erro ao salvar como:', err);
      this.showNotification('❌ Erro ao salvar documento!', 'error');
    }
  }
  
  async newDocument() {
    if (!this.workingDirectory) {
      await this.requestWorkingDirectory();
      if (!this.workingDirectory) return;
    }
    
    const fileName = prompt('Nome do novo documento:', 'documento.tex');
    if (!fileName) return;
    
    const finalFileName = fileName.endsWith('.tex') ? fileName : fileName + '.tex';
    
    try {
      const fileHandle = await this.workingDirectory.getFileHandle(finalFileName, { create: true });
      
      const defaultContent = `% ${finalFileName}
\\documentclass[12pt,a4paper]{article}

% Pacotes essenciais
\\usepackage[utf8]{inputenc}
\\usepackage[portuguese]{babel}
\\usepackage{graphicx}

% Informações do documento
\\title{Título do Documento}
\\author{Seu Nome}
\\date{\\today}

\\begin{document}

\\maketitle

\\section{Introdução}

Escreva seu conteúdo aqui.

\\end{document}`;
      
      const writable = await fileHandle.createWritable();
      await writable.write(defaultContent);
      await writable.close();
      
      this.currentFileHandle = fileHandle;
      this.editor.value = defaultContent;
      this.fileName.textContent = finalFileName;
      this.updateLineNumbers();
      this.updateStatus();
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Novo documento criado: ' + finalFileName, 'success');
      
      await this.updateFilesList();
    } catch (err) {
      console.error('Erro ao criar documento:', err);
      this.showNotification('❌ Erro ao criar documento!', 'error');
    }
  }
  
  async openDocument() {
    if (!this.workingDirectory) {
      await this.requestWorkingDirectory();
      if (!this.workingDirectory) return;
    }
    
    try {
      const [fileHandle] = await window.showOpenFilePicker({
        types: [{
          description: 'Arquivos LaTeX',
          accept: { 'text/plain': ['.tex'] }
        }],
        startIn: this.workingDirectory
      });
      
      this.currentFileHandle = fileHandle;
      const file = await fileHandle.getFile();
      const content = await file.text();
      
      this.editor.value = content;
      this.fileName.textContent = fileHandle.name;
      this.updateLineNumbers();
      this.updateStatus();
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Documento aberto: ' + fileHandle.name, 'success');
      
      await this.updateFilesList();
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('Erro ao abrir documento:', err);
        this.showNotification('❌ Erro ao abrir documento!', 'error');
      }
    }
  }
  
  async createFolder() {
    if (!this.workingDirectory) {
      this.showNotification('❌ Selecione a pasta "Arquivos" primeiro!', 'error');
      return;
    }
    
    const folderName = prompt('Nome da pasta:', 'nova_pasta');
    if (!folderName) return;
    
    try {
      await this.workingDirectory.getDirectoryHandle(folderName, { create: true });
      this.showNotification('✓ Pasta criada: ' + folderName, 'success');
    } catch (err) {
      console.error('Erro ao criar pasta:', err);
      this.showNotification('❌ Erro ao criar pasta!', 'error');
    }
  }
  
  // ============================================================================
  // GERENCIAMENTO DE IMAGENS
  // ============================================================================
  
  setupImageDragDrop() {
    const imagesList = document.getElementById('imagesList');
    const editor = this.editor;
    
    if (!imagesList) return;
    
    // Drag and drop na lista de imagens
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      imagesList.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    });
    
    ['dragenter', 'dragover'].forEach(eventName => {
      imagesList.addEventListener(eventName, () => {
        imagesList.classList.add('drag-over');
      });
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
      imagesList.addEventListener(eventName, () => {
        imagesList.classList.remove('drag-over');
      });
    });
    
    imagesList.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      this.handleImageFiles(files);
    });
    
    // Drag and drop no editor
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      editor.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    });
    
    editor.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      const imageFiles = Array.from(files).filter(file => 
        file.type.startsWith('image/') || file.name.endsWith('.pdf')
      );
      
      if (imageFiles.length > 0) {
        this.handleImageFiles(imageFiles);
      }
    });
  }
  
  async uploadImage() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/png,image/jpeg,image/jpg,image/svg+xml,application/pdf';
    input.multiple = true;
    
    input.onchange = async (e) => {
      const files = e.target.files;
      if (files.length > 0) {
        await this.handleImageFiles(files);
      }
    };
    
    input.click();
  }
  
  async handleImageFiles(files) {
    if (!this.workingDirectory) {
      this.showNotification('❌ Selecione a pasta de trabalho primeiro!', 'error');
      return;
    }
    
    try {
      // Obter ou criar diretório "imagens"
      let imagesDir;
      try {
        imagesDir = await this.workingDirectory.getDirectoryHandle('imagens', { create: true });
      } catch (err) {
        console.error('Erro ao criar diretório de imagens:', err);
        this.showNotification('❌ Erro ao acessar pasta de imagens!', 'error');
        return;
      }
      
      this.imagesDirectory = imagesDir;
      
      // Processar cada arquivo
      for (const file of files) {
        // Validar tipo de arquivo
        const validTypes = ['image/png', 'image/jpeg', 'image/jpg', 'image/svg+xml', 'application/pdf'];
        if (!validTypes.includes(file.type) && !file.name.match(/\.(png|jpe?g|svg|pdf)$/i)) {
          this.showNotification(`⚠️ Tipo de arquivo não suportado: ${file.name}`, 'warning');
          continue;
        }
        
        try {
          // Criar arquivo no diretório de imagens
          const fileHandle = await imagesDir.getFileHandle(file.name, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(file);
          await writable.close();
          
          this.showNotification(`✓ Imagem salva: ${file.name}`, 'success');
        } catch (err) {
          console.error('Erro ao salvar imagem:', err);
          this.showNotification(`❌ Erro ao salvar: ${file.name}`, 'error');
        }
      }
      
      // Atualizar lista de imagens
      await this.updateImagesList();
      
    } catch (err) {
      console.error('Erro ao processar imagens:', err);
      this.showNotification('❌ Erro ao processar imagens!', 'error');
    }
  }
  
  async updateImagesList() {
    const imagesList = document.getElementById('imagesList');
    if (!imagesList) return;
    
    if (!this.workingDirectory) {
      imagesList.innerHTML = `
        <div class="images-empty">
          <i class="fas fa-image"></i>
          <p>Nenhuma pasta selecionada</p>
          <small>Selecione a pasta de trabalho primeiro</small>
        </div>
      `;
      return;
    }
    
    try {
      // Obter diretório de imagens
      let imagesDir;
      try {
        imagesDir = await this.workingDirectory.getDirectoryHandle('imagens');
      } catch (err) {
        // Diretório não existe ainda
        imagesList.innerHTML = `
          <div class="images-empty">
            <i class="fas fa-image"></i>
            <p>Nenhuma imagem ainda</p>
            <small>Clique em <i class="fas fa-upload"></i> ou arraste aqui</small>
          </div>
        `;
        return;
      }
      
      this.imagesDirectory = imagesDir;
      
      // Listar imagens
      const images = [];
      for await (const entry of imagesDir.values()) {
        if (entry.kind === 'file') {
          const name = entry.name.toLowerCase();
          if (name.match(/\.(png|jpe?g|svg|pdf)$/)) {
            images.push(entry);
          }
        }
      }
      
      if (images.length === 0) {
        imagesList.innerHTML = `
          <div class="images-empty">
            <i class="fas fa-image"></i>
            <p>Nenhuma imagem encontrada</p>
            <small>Faça upload de imagens!</small>
          </div>
        `;
        return;
      }
      
      // Ordenar por nome
      images.sort((a, b) => a.name.localeCompare(b.name));
      
      // Renderizar lista com preview
      const imageItems = await Promise.all(images.map(async (fileHandle) => {
        const file = await fileHandle.getFile();
        const url = URL.createObjectURL(file);
        const ext = file.name.split('.').pop().toLowerCase();
        
        // Determinar ícone
        let icon = 'fa-file-image';
        if (ext === 'pdf') icon = 'fa-file-pdf';
        else if (ext === 'svg') icon = 'fa-file-code';
        
        // Preview apenas para imagens (não PDF)
        const preview = ext !== 'pdf' ? 
          `<img src="${url}" class="image-preview" alt="${file.name}">` :
          `<div class="image-preview" style="display:flex;align-items:center;justify-content:center;"><i class="fas fa-file-pdf" style="font-size:2rem;color:#dc3545;"></i></div>`;
        
        return `
          <div class="image-item">
            ${preview}
            <div class="image-info">
              <i class="fas ${icon}"></i>
              <span class="image-name" title="${file.name}">${file.name}</span>
            </div>
            <div class="image-actions">
              <button class="image-action-btn insert" onclick="window.latexEditor.insertImageCode('${file.name}')" title="Inserir no documento">
                <i class="fas fa-plus"></i> Inserir
              </button>
              <button class="image-action-btn delete" onclick="window.latexEditor.deleteImage('${file.name}')" title="Excluir imagem">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      }));
      
      imagesList.innerHTML = imageItems.join('');
      
    } catch (err) {
      console.error('Erro ao listar imagens:', err);
      imagesList.innerHTML = `
        <div class="images-empty">
          <i class="fas fa-exclamation-triangle"></i>
          <p>Erro ao listar imagens</p>
          <small>${err.message}</small>
        </div>
      `;
    }
  }
  
  insertImageCode(imageName) {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const value = this.editor.value;
    
    // Gerar código LaTeX para a imagem
    const imageCode = `
\\begin{figure}[h]
  \\centering
  \\includegraphics[width=0.8\\textwidth]{imagens/${imageName}}
  \\caption{Legenda da imagem}
  \\label{fig:${imageName.replace(/\.[^.]+$/, '').replace(/[^a-zA-Z0-9]/g, '_')}}
\\end{figure}
`;
    
    // Inserir no editor
    this.editor.value = value.substring(0, start) + imageCode + value.substring(end);
    
    // Posicionar cursor na legenda
    const captionPos = start + imageCode.indexOf('Legenda da imagem');
    this.editor.selectionStart = captionPos;
    this.editor.selectionEnd = captionPos + 'Legenda da imagem'.length;
    
    this.editor.focus();
    this.updateLineNumbers();
    this.updateStatus();
    this.isModified = true;
    this.fileStatus.textContent = '●';
    this.fileStatus.style.color = '#f56565';
    
    this.showNotification(`✓ Imagem inserida: ${imageName}`, 'success');
  }
  
  async deleteImage(imageName) {
    if (!confirm(`Deseja realmente excluir a imagem "${imageName}"?`)) {
      return;
    }
    
    if (!this.imagesDirectory) {
      this.showNotification('❌ Diretório de imagens não encontrado!', 'error');
      return;
    }
    
    try {
      await this.imagesDirectory.removeEntry(imageName);
      this.showNotification(`✓ Imagem excluída: ${imageName}`, 'success');
      await this.updateImagesList();
    } catch (err) {
      console.error('Erro ao excluir imagem:', err);
      this.showNotification('❌ Erro ao excluir imagem!', 'error');
    }
  }
  
  setupEventListeners() {
    this.editor.addEventListener('input', () => {
      this.updateLineNumbers();
      this.updateStatus();
      this.updateFileStatus();
      this.saveToHistory();
    });
    
    // Adicionar evento para detectar paste (colar)
    this.editor.addEventListener('paste', () => {
      setTimeout(() => {
        this.updateLineNumbers();
        this.updateStatus();
      }, 10);
    });
    
    // Adicionar evento para detectar mudanças no valor
    this.editor.addEventListener('change', () => {
      this.updateLineNumbers();
      this.updateStatus();
    });
    
    // Atualizar em CADA input (mais frequente)
    this.editor.addEventListener('input', () => {
      this.updateLineNumbers();
    });
    
    this.editor.addEventListener('keydown', (e) => {
      this.handleKeyDown(e);
    });
    
    this.editor.addEventListener('scroll', () => {
      this.syncLineNumbers();
      // Atualizar marcadores do linter se existir
      if (window.linterUI) {
        window.linterUI.updateAllMarkerPositions();
      }
    });
    
    this.editor.addEventListener('selectionchange', () => {
      this.updateCursorPosition();
    });
    
    // Verificação periódica para garantir sincronização (fallback)
    setInterval(() => {
      const lines = this.editor.value.split('\n').length;
      const numbers = this.lineNumbers.querySelectorAll('.line-number').length;
      if (lines !== numbers) {
        console.warn(`[Editor] Dessincronizado! Forçando atualização: ${numbers} → ${lines}`);
        this.updateLineNumbers();
      }
    }, 2000); // Verificar a cada 2 segundos
  }
  
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey) {
        switch(e.key) {
          case 's': e.preventDefault(); this.saveDocument(); break;
          case 'n': e.preventDefault(); this.newDocument(); break;
          case 'o': e.preventDefault(); this.openDocument(); break;
          case 'z': e.preventDefault(); this.undoAction(); break;
          case 'y': e.preventDefault(); this.redoAction(); break;
          case 'b': e.preventDefault(); this.formatText('bold'); break;
          case 'i': e.preventDefault(); this.formatText('italic'); break;
          case 'u': e.preventDefault(); this.formatText('underline'); break;
        }
      }
      
      if (e.key === 'F5') { e.preventDefault(); this.compileDocument(); }
      if (e.key === 'F6') { e.preventDefault(); this.previewDocument(); }
    });
  }
  
  handleKeyDown(e) {
    if (e.key === 'Tab') {
      e.preventDefault();
      this.insertTab();
    }
    
    if (e.key === 'Enter') {
      setTimeout(() => this.autoIndent(), 0);
    }
    
    if (e.key === '{') {
      setTimeout(() => this.insertLaTeXPair('{', '}'), 0);
    }
    
    if (e.key === '[') {
      setTimeout(() => this.insertLaTeXPair('[', ']'), 0);
    }
  }
  
  insertTab() {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const value = this.editor.value;
    this.editor.value = value.substring(0, start) + '  ' + value.substring(end);
    this.editor.selectionStart = this.editor.selectionEnd = start + 2;
  }
  
  autoIndent() {
    const cursorPos = this.editor.selectionStart;
    const lines = this.editor.value.substring(0, cursorPos).split('\n');
    let indentLevel = 0;
    
    for (let i = 0; i < lines.length - 1; i++) {
      const line = lines[i];
      if (line.match(/\\begin\{/)) indentLevel++;
      if (line.match(/\\end\{/)) indentLevel--;
    }
    
    const indent = '  '.repeat(Math.max(0, indentLevel));
    const currentLine = lines[lines.length - 1];
    
    if (currentLine.trim() === '') {
      this.editor.value = this.editor.value.substring(0, cursorPos) + indent + this.editor.value.substring(cursorPos);
      this.editor.selectionStart = this.editor.selectionEnd = cursorPos + indent.length;
    }
  }
  
  insertLaTeXPair(open, close) {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const value = this.editor.value;
    
    if (start === end) {
      this.editor.value = value.substring(0, start) + open + close + value.substring(end);
      this.editor.selectionStart = this.editor.selectionEnd = start + 1;
    } else {
      const selected = value.substring(start, end);
      this.editor.value = value.substring(0, start) + open + selected + close + value.substring(end);
      this.editor.selectionStart = start + 1;
      this.editor.selectionEnd = start + 1 + selected.length;
    }
  }
  
  updateLineNumbers() {
    const lines = this.editor.value.split('\n');
    const currentCount = this.lineNumbers.querySelectorAll('.line-number').length;
    
    // Só atualizar se o número mudou (performance)
    if (currentCount !== lines.length) {
      const lineNumbersHtml = lines.map((_, index) => 
        `<div class="line-number">${index + 1}</div>`
      ).join('');
      this.lineNumbers.innerHTML = lineNumbersHtml;
    }
    
    // Sincronizar scroll
    this.syncLineNumbers();
  }
  
  syncLineNumbers() {
    this.lineNumbers.scrollTop = this.editor.scrollTop;
  }
  
  updateStatus() {
    const text = this.editor.value;
    const words = text.trim().split(/\s+/).filter(word => word.length > 0);
    this.documentLength.textContent = `${text.length} caracteres`;
    this.wordCount.textContent = `${words.length} palavras`;
  }
  
  updateCursorPosition() {
    const cursorPos = this.editor.selectionStart;
    const textBeforeCursor = this.editor.value.substring(0, cursorPos);
    const lines = textBeforeCursor.split('\n');
    const line = lines.length;
    const column = lines[lines.length - 1].length + 1;
    this.cursorPosition.textContent = `Linha ${line}, Coluna ${column}`;
  }
  
  updateFileStatus() {
    this.isModified = true;
    this.fileStatus.textContent = '●';
    this.fileStatus.style.color = '#f56565';
  }
  
  saveToHistory() {
    const currentState = this.editor.value;
    if (this.history[this.historyIndex] !== currentState) {
      this.history = this.history.slice(0, this.historyIndex + 1);
      this.history.push(currentState);
      this.historyIndex++;
      
      if (this.history.length > 50) {
        this.history.shift();
        this.historyIndex--;
      }
    }
  }
  
  // Funções dos botões
  async saveDocument() {
    const content = this.editor.value;
    const fileName = this.fileName.textContent;
    
    // Verificar se estamos em localhost (File System Access API disponível)
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    // Se estamos em servidor remoto, usar API do backend
    if (!isLocalhost) {
      try {
        const response = await fetch('/api/save-latex', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            filename: fileName,
            content: content
          })
        });
        
        const data = await response.json();
        
        if (data.success) {
          this.fileStatus.textContent = '●';
          this.fileStatus.style.color = '#68d391';
          this.isModified = false;
          this.showNotification('✓ Documento salvo com sucesso!', 'success');
        } else {
          throw new Error(data.error || 'Erro ao salvar');
        }
        return;
      } catch (err) {
        console.error('Erro ao salvar via API:', err);
        this.showNotification('❌ Erro ao salvar documento!', 'error');
        return;
      }
    }
    
    // No localhost, sempre abrir diálogo de salvamento
    if (window.showSaveFilePicker) {
      try {
        // Configurar opções do diálogo
        const options = {
          suggestedName: fileName || 'documento.tex',
          types: [{
            description: 'LaTeX Document',
            accept: {'text/plain': ['.tex']}
          }],
          startIn: 'documents' // Tentar iniciar em Documentos
        };
        
        // Se temos um diretório de trabalho, usar ele
        if (this.workingDirectory) {
          options.startIn = this.workingDirectory;
        }
        
        const fileHandle = await window.showSaveFilePicker(options);
        
        this.currentFileHandle = fileHandle;
        this.fileName.textContent = fileHandle.name;
        
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        
        this.fileStatus.textContent = '●';
        this.fileStatus.style.color = '#68d391';
        this.isModified = false;
        this.showNotification('✓ Documento salvo com sucesso!', 'success');
        
        // Atualizar lista de arquivos
        this.updateFilesList();
        return;
      } catch (err) {
        console.error('Erro ao salvar arquivo:', err);
        this.showNotification('❌ Erro ao salvar documento!', 'error');
        return;
      }
    }
    
    // Se não temos fileHandle, pedir ao usuário onde salvar (abrindo na pasta Arquivos)
    if (window.showSaveFilePicker) {
      try {
        // Tentar obter o diretório "Arquivos" como startIn
        let options = {
          suggestedName: fileName,
          types: [{
            description: 'LaTeX Document',
            accept: {'text/plain': ['.tex']}
          }]
        };
        
        // Se temos um diretório de trabalho, usar ele
        if (this.workingDirectory) {
          options.startIn = this.workingDirectory;
        }
        
        const fileHandle = await window.showSaveFilePicker(options);
        
        this.currentFileHandle = fileHandle;
        this.fileName.textContent = fileHandle.name;
        
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        
        this.fileStatus.textContent = '●';
        this.fileStatus.style.color = '#68d391';
        this.isModified = false;
        this.showNotification('✓ Documento salvo com sucesso!', 'success');
        
        // Atualizar lista de arquivos
        this.updateFilesList();
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Erro ao salvar arquivo:', err);
          this.showNotification('❌ Erro ao salvar documento!', 'error');
        }
      }
    } else {
      // Fallback: download do arquivo
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
      
      this.fileStatus.textContent = '●';
      this.fileStatus.style.color = '#68d391';
      this.isModified = false;
      this.showNotification('✓ Documento baixado!', 'info');
    }
  }
  
  newDocument() {
    // Só avisar se realmente houver modificações não salvas
    if (this.isModified && this.editor.value.trim() !== '' && !confirm('Documento não salvo. Deseja continuar?')) {
      return;
    }
    
    // SEMPRE solicitar o nome do arquivo
    const fileName = prompt('📄 Digite o nome do arquivo (com extensão .tex):', 'documento.tex');
    if (!fileName) return;
    
    // Garantir que tem extensão .tex
    const finalFileName = fileName.endsWith('.tex') ? fileName : fileName + '.tex';
    this.fileName.textContent = finalFileName;
    
    // Criar o conteúdo do documento
    this.editor.value = `% Novo Documento LaTeX
\\documentclass[12pt,a4paper]{article}

% Pacotes essenciais
\\usepackage[utf8]{inputenc}
\\usepackage[portuguese]{babel}
\\usepackage[T1]{fontenc}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{amssymb}

\\begin{document}

% Título do documento
\\title{Novo Documento}
\\author{Seu Nome}
\\date{\\today}

\\maketitle

% Conteúdo aqui

\\end{document}`;
    
    this.updateLineNumbers();
    this.updateStatus();
    this.fileStatus.textContent = '●';
    this.fileStatus.style.color = '#f56565';
    this.isModified = true;
    this.editor.focus();
    
    // Limpar fileHandle para forçar "Salvar Como" na primeira vez
    this.currentFileHandle = null;
    
    this.showNotification('✓ Novo documento criado! Use Ctrl+S para escolher onde salvar.', 'success');
  }
  
  async openDocument() {
    // Usar File System Access API se disponível
    if (window.showOpenFilePicker) {
      try {
        let options = {
          types: [{
            description: 'LaTeX Document',
            accept: {'text/plain': ['.tex']}
          }],
          multiple: false
        };
        
        // Se temos um diretório de trabalho, usar ele
        if (this.workingDirectory) {
          options.startIn = this.workingDirectory;
        }
        
        const [fileHandle] = await window.showOpenFilePicker(options);
        
        this.currentFileHandle = fileHandle;
        const file = await fileHandle.getFile();
        const content = await file.text();
        
        this.editor.value = content;
        this.fileName.textContent = fileHandle.name;
        this.updateLineNumbers();
        this.updateStatus();
        this.fileStatus.textContent = '●';
        this.fileStatus.style.color = '#68d391';
        this.isModified = false;
        this.showNotification('✓ Documento carregado com sucesso!', 'success');
        
        // Atualizar lista de arquivos
        this.updateFilesList();
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Erro ao abrir arquivo:', err);
          this.showNotification('❌ Erro ao abrir documento!', 'error');
        }
      }
    } else {
      // Fallback para navegadores antigos
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.tex';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            this.editor.value = e.target.result;
            this.fileName.textContent = file.name;
            this.updateLineNumbers();
            this.updateStatus();
            this.fileStatus.textContent = '●';
            this.fileStatus.style.color = '#68d391';
            this.isModified = false;
            this.showNotification('✓ Documento carregado!', 'success');
          };
          reader.readAsText(file);
        }
      };
      input.click();
    }
  }
  
  undoAction() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.editor.value = this.history[this.historyIndex];
      this.updateLineNumbers();
      this.updateStatus();
    }
  }
  
  redoAction() {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.editor.value = this.history[this.historyIndex];
      this.updateLineNumbers();
      this.updateStatus();
    }
  }
  
  formatText(type) {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const value = this.editor.value;
    const selectedText = value.substring(start, end);
    
    let formattedText = '';
    switch(type) {
      case 'bold': formattedText = selectedText ? `\\textbf{${selectedText}}` : '\\textbf{texto}'; break;
      case 'italic': formattedText = selectedText ? `\\textit{${selectedText}}` : '\\textit{texto}'; break;
      case 'underline': formattedText = selectedText ? `\\underline{${selectedText}}` : '\\underline{texto}'; break;
    }
    
    this.editor.value = value.substring(0, start) + formattedText + value.substring(end);
    
    if (!selectedText) {
      const newCursorPos = start + formattedText.indexOf('{') + 1;
      this.editor.selectionStart = this.editor.selectionEnd = newCursorPos;
    } else {
      this.editor.selectionStart = start + formattedText.length;
      this.editor.selectionEnd = start + formattedText.length;
    }
    
    this.editor.focus();
    this.updateLineNumbers();
    this.updateStatus();
  }
  
  insertSnippet(type) {
    const snippets = {
      section: '\\section{Título da Seção}\n\n',
      equation: '\\begin{equation}\n  \n\\end{equation}\n',
      table: `\\begin{table}[h]
  \\centering
  \\begin{tabular}{|c|c|}
    \\hline
    Coluna 1 & Coluna 2 \\\\
    \\hline
    Dados 1 & Dados 2 \\\\
    \\hline
  \\end{tabular}
  \\caption{Título}
\\end{table}`,
      list: `\\begin{itemize}
  \\item Primeiro item
  \\item Segundo item
\\end{itemize}`,
      figure: `\\begin{figure}[h]
  \\centering
  \\includegraphics[width=0.8\\textwidth]{imagem.png}
  \\caption{Título}
\\end{figure}`
    };
    
    if (snippets[type]) {
      this.insertTextAtCursor(snippets[type]);
    }
  }
  
  insertTextAtCursor(text) {
    const start = this.editor.selectionStart;
    const end = this.editor.selectionEnd;
    const value = this.editor.value;
    
    this.editor.value = value.substring(0, start) + text + value.substring(end);
    this.editor.selectionStart = this.editor.selectionEnd = start + text.length;
    this.editor.focus();
  }
  
  compileDocument() {
    const content = this.editor.value;
    const fileName = this.fileName.textContent.replace('.tex', '');
    
    if (!content.trim()) {
      this.showNotification('Nenhum conteúdo para compilar!', 'warning');
      return;
    }
    
    this.showNotification('Compilando com pdflatex...', 'info');
    
    console.log('Enviando para compilação:', { filename: fileName, contentLength: content.length });
    
    // Enviar conteúdo sem escape duplo de barras invertidas
    const payload = JSON.stringify({ 
      filename: fileName, 
      content: content 
    });
    
    fetch('/api/compile-latex', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: payload
    })
    .then(response => {
      console.log('Resposta da compilação:', response.status, response.statusText);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return response.json();
    })
    .then(data => {
      console.log('[Compilação] === RESPOSTA ===');
      console.log('[Compilação] success:', data.success);
      console.log('[Compilação] error:', data.error);
      console.log('[Compilação] pdf_url:', data.pdf_url);
      
      if (data.success) {
        console.log('[Compilação] ✅ SUCESSO! PDF URL:', data.pdf_url);
        
        if (data.pdf_url) {
          // Extrair o nome do arquivo do PDF
          const pdfFilename = data.pdf_url.split('/').pop();
          const viewerUrl = `/view_pdf/${pdfFilename}`;
          
          // Criar link de download
          const downloadLink = document.createElement('a');
          downloadLink.href = viewerUrl;
          downloadLink.target = '_blank';
          downloadLink.textContent = '📄 Clique para abrir o PDF';
          downloadLink.style.cssText = 'color: white; font-weight: bold; text-decoration: underline; cursor: pointer; display: block; margin-top: 8px;';
          
          downloadLink.onclick = (e) => {
            e.stopPropagation();
          };
          
          this.showNotification('✓ Compilação bem-sucedida! ', 'success', downloadLink);
          
          // Abrir PDF em modal ao invés de nova aba
          setTimeout(() => {
            this.showPDFModal(viewerUrl, pdfFilename);
          }, 300);
        } else {
          this.showNotification('✓ Compilação bem-sucedida!', 'success');
        }
      } else {
        console.error('[Compilação] ❌ ERRO!');
        console.error('[Compilação] Mensagem:', data.error);
        
        this.showNotification('Erro na compilação: ' + (data.error || 'Erro desconhecido'), 'error');
        
        if (data.log) {
          console.error('[Compilação] === LOG COMPLETO ===');
          console.error(data.log);
          
          // Encontrar linhas com "!" (erros) no log
          const logLines = data.log.split('\n');
          const errorLines = logLines.filter(line => line.trim().startsWith('!'));
          
          if (errorLines.length > 0) {
            console.error('[Compilação] === ERROS NO LOG ===');
            errorLines.forEach((line, i) => {
              console.error(`  ${i+1}. ${line}`);
              // Mostrar também as próximas 2 linhas (contexto do erro)
              const nextLine1 = logLines[logLines.indexOf(line) + 1];
              const nextLine2 = logLines[logLines.indexOf(line) + 2];
              if (nextLine1) console.error(`      ${nextLine1}`);
              if (nextLine2) console.error(`      ${nextLine2}`);
            });
          } else {
            console.warn('[Compilação] Nenhuma linha com "!" encontrada. Procurando outros padrões...');
            
            // Procurar outros padrões de erro
            const errorPatterns = [
              /error/i,
              /undefined/i,
              /missing/i,
              /fatal/i,
              /emergency stop/i
            ];
            
            const possibleErrors = logLines.filter(line => 
              errorPatterns.some(pattern => pattern.test(line))
            );
            
            if (possibleErrors.length > 0) {
              console.error('[Compilação] === POSSÍVEIS ERROS ===');
              possibleErrors.slice(0, 10).forEach((line, i) => {
                console.error(`  ${i+1}. ${line}`);
              });
            }
          }
          
          // Mostrar as últimas 50 linhas do log
          const lastLines = logLines.slice(-50).join('\n');
          console.error('[Compilação] === ÚLTIMAS 50 LINHAS ===');
          console.error(lastLines);
        }
      }
    })
    .catch(error => {
      this.showNotification('Erro de conexão na compilação! Mostrando PDF de exemplo...', 'warning');
      this.showExamplePDF();
    });
  }
  
  showExamplePDF() {
    const examplePDF = '/static/sample.pdf';
    
    fetch(examplePDF)
      .then(response => {
        if (response.ok) {
          const pdfWindow = window.open(examplePDF, '_blank');
          if (pdfWindow) {
            pdfWindow.focus();
            this.showNotification('PDF de exemplo aberto com instruções LaTeX!', 'info');
          } else {
            this.showNotification('Popup bloqueado. Clique aqui para abrir o PDF de exemplo.', 'warning');
            const link = document.createElement('a');
            link.href = examplePDF;
            link.target = '_blank';
            link.textContent = 'Abrir PDF de Exemplo';
            link.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #007bff; color: white; padding: 1rem 2rem; border-radius: 4px; text-decoration: none; z-index: 1001;';
            document.body.appendChild(link);
            setTimeout(() => link.remove(), 10000);
          }
        } else {
          throw new Error('PDF de exemplo não disponível');
        }
      })
      .catch(error => {
        this.showNotification('PDF de exemplo não disponível. Verifique se o LaTeX está instalado no sistema.', 'error');
      });
  }
  
  previewDocument() {
    this.compileDocument();
  }
  
  closeTab(fileName) {
    if (this.isModified && !confirm('Documento não salvo. Deseja fechar?')) return;
    this.showNotification('Aba fechada!', 'info');
  }
  
  showPDFModal(pdfUrl, filename) {
    // Criar modal se não existir
    let modal = document.getElementById('pdfModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'pdfModal';
      modal.innerHTML = `
        <div class="pdf-modal-overlay" onclick="closePDFModal()"></div>
        <div class="pdf-modal-content">
          <div class="pdf-modal-header">
            <h3><i class="fas fa-file-pdf"></i> <span id="pdfModalTitle">PDF Compilado</span></h3>
            <div class="pdf-modal-actions">
              <button onclick="downloadPDFFromModal()" class="pdf-action-btn pdf-download-btn" title="Download PDF">
                <i class="fas fa-download"></i>
                <span>Salvar</span>
              </button>
              <button onclick="printPDFFromModal()" class="pdf-action-btn pdf-print-btn" title="Imprimir PDF">
                <i class="fas fa-print"></i>
                <span>Imprimir</span>
              </button>
              <button onclick="closePDFModal()" class="pdf-action-btn pdf-back-btn" title="Voltar ao Editor">
                <i class="fas fa-arrow-left"></i>
                <span>Voltar ao Editor</span>
              </button>
              <button onclick="closePDFModal()" class="pdf-modal-close" title="Fechar">
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
          <div class="pdf-modal-body">
            <iframe id="pdfIframe" style="width: 100%; height: 100%; border: none;"></iframe>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Adicionar estilos
      const style = document.createElement('style');
      style.textContent = `
        #pdfModal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 10000;
          display: none;
          animation: fadeIn 0.2s;
        }
        
        #pdfModal.active {
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .pdf-modal-overlay {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.7);
          backdrop-filter: blur(4px);
        }
        
        .pdf-modal-content {
          position: relative;
          width: 90%;
          max-width: 1200px;
          height: 90%;
          background: white;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          display: flex;
          flex-direction: column;
          animation: slideUp 0.3s ease;
        }
        
        .pdf-modal-header {
          padding: 1.5rem;
          border-bottom: 1px solid #e0e0e0;
          display: flex;
          justify-content: space-between;
          align-items: center;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          border-radius: 12px 12px 0 0;
        }
        
        .pdf-modal-header h3 {
          margin: 0;
          font-size: 1.25rem;
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }
        
        .pdf-modal-actions {
          display: flex;
          align-items: center;
          gap: 0.5rem;
        }
        
        .pdf-action-btn {
          background: rgba(255,255,255,0.2);
          border: 1px solid rgba(255,255,255,0.3);
          color: white;
          padding: 0.5rem 1rem;
          border-radius: 6px;
          cursor: pointer;
          font-size: 0.9rem;
          display: inline-flex;
          align-items: center;
          gap: 0.5rem;
          transition: all 0.3s ease;
          font-weight: 500;
        }
        
        .pdf-action-btn:hover {
          background: rgba(255,255,255,0.3);
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .pdf-download-btn:hover {
          background: rgba(40, 167, 69, 0.8);
          border-color: rgba(40, 167, 69, 1);
        }
        
        .pdf-print-btn:hover {
          background: rgba(0, 123, 255, 0.8);
          border-color: rgba(0, 123, 255, 1);
        }
        
        .pdf-back-btn:hover {
          background: rgba(108, 117, 125, 0.8);
          border-color: rgba(108, 117, 125, 1);
        }
        
        .pdf-modal-close {
          background: rgba(255,255,255,0.2);
          border: 1px solid rgba(255,255,255,0.3);
          color: white;
          font-size: 1.2rem;
          cursor: pointer;
          width: 36px;
          height: 36px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: all 0.3s ease;
          margin-left: 0.5rem;
        }
        
        .pdf-modal-close:hover {
          background: rgba(220, 53, 69, 0.8);
          border-color: rgba(220, 53, 69, 1);
          transform: rotate(90deg);
        }
        
        .pdf-modal-body {
          flex: 1;
          padding: 1rem;
          overflow: hidden;
        }
        
        @keyframes fadeIn {
          from { opacity: 0; }
          to { opacity: 1; }
        }
        
        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(50px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
        
        /* Responsividade para mobile */
        @media (max-width: 768px) {
          .pdf-modal-content {
            width: 95%;
            height: 95%;
          }
          
          .pdf-modal-header {
            flex-direction: column;
            gap: 1rem;
            padding: 1rem;
          }
          
          .pdf-modal-actions {
            width: 100%;
            justify-content: space-between;
            flex-wrap: wrap;
          }
          
          .pdf-action-btn span {
            display: none;
          }
          
          .pdf-action-btn {
            padding: 0.5rem;
            min-width: 40px;
            justify-content: center;
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Atualizar conteúdo e mostrar
    document.getElementById('pdfModalTitle').textContent = filename || 'PDF Compilado';
    const iframe = document.getElementById('pdfIframe');
    iframe.src = pdfUrl;
    
    // Armazenar PDF URL e filename para funções de download e impressão
    window.currentPdfUrl = pdfUrl;
    window.currentPdfFilename = filename || 'documento.pdf';
    
    modal.classList.add('active');
    
    // Permitir fechar com ESC
    document.addEventListener('keydown', function escHandler(e) {
      if (e.key === 'Escape') {
        closePDFModal();
        document.removeEventListener('keydown', escHandler);
      }
    });
  }
  
  showNotification(message, type, extraElement = null) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    // Se for string, usar textContent; senão criar um span
    if (typeof message === 'string') {
      const messageSpan = document.createElement('span');
      messageSpan.textContent = message;
      notification.appendChild(messageSpan);
    } else {
      notification.appendChild(message);
    }
    
    // Adicionar elemento extra se fornecido (como link de download)
    if (extraElement) {
      notification.appendChild(extraElement);
    }
    
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      color: white;
      font-weight: 500;
      z-index: 1000;
      animation: slideIn 0.3s ease;
      max-width: 350px;
      word-wrap: break-word;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      cursor: pointer;
    `;
    
    const colors = {
      success: '#38a169',
      error: '#e53e3e',
      info: '#3182ce',
      warning: '#d69e2e'
    };
    
    notification.style.backgroundColor = colors[type] || colors.info;
    
    // Fechar ao clicar
    notification.addEventListener('click', () => notification.remove());
    
    document.body.appendChild(notification);
    
    const displayTime = type === 'error' ? 8000 : 5000;
    setTimeout(() => notification.remove(), displayTime);
  }
  
  goToLine(lineNumber) {
    // Ir para a linha especificada
    const lines = this.editor.value.split('\n');
    
    if (lineNumber < 1 || lineNumber > lines.length) {
      this.showNotification(`Linha ${lineNumber} não existe no documento`, 'warning');
      return;
    }
    
    console.log(`[goToLine] Indo para linha ${lineNumber} de ${lines.length}`);
    
    // Calcular a posição do cursor (início da linha)
    let position = 0;
    for (let i = 0; i < lineNumber - 1; i++) {
      position += lines[i].length + 1; // +1 para o \n
    }
    
    // Mover cursor para a linha
    this.editor.focus();
    
    // Scroll para tornar a linha visível
    const lineHeight = parseFloat(window.getComputedStyle(this.editor).lineHeight) || 21;
    const scrollTop = (lineNumber - 1) * lineHeight;
    this.editor.scrollTop = scrollTop - (this.editor.clientHeight / 3); // Centralizar aproximadamente
    
    // Destacar a linha temporariamente com seleção
    const lineEnd = position + lines[lineNumber - 1].length;
    this.editor.setSelectionRange(position, lineEnd);
    
    // Criar destaque visual SIMPLES e DIRETO
    const highlightBg = document.getElementById('lineHighlightBg');
    if (highlightBg) {
      console.log('[goToLine] Criando destaque visual');
      
      // Calcular a posição exata da linha
      const topPosition = (lineNumber - 1) * lineHeight;
      
      // Criar apenas UMA div com o destaque
      highlightBg.innerHTML = `
        <div style="
          position: absolute;
          top: ${topPosition}px;
          left: 0;
          right: 0;
          height: ${lineHeight}px;
          background: rgba(255, 193, 7, 0.5) !important;
          border-left: 5px solid #ff5722 !important;
          box-shadow: 0 0 10px rgba(255, 152, 0, 0.3);
          animation: highlightPulse 2s ease-in-out;
          z-index: 10;
        ">&nbsp;</div>
      `;
      
      // Sincronizar scroll do fundo com o editor
      const syncScroll = () => {
        highlightBg.style.transform = `translateY(-${this.editor.scrollTop}px)`;
      };
      
      // Aplicar scroll inicial
      syncScroll();
      
      // Adicionar listener de scroll
      this.editor.addEventListener('scroll', syncScroll);
      
      // Remover destaque após 3 segundos
      setTimeout(() => {
        highlightBg.innerHTML = '';
        this.editor.setSelectionRange(position, position);
        this.editor.removeEventListener('scroll', syncScroll);
        console.log('[goToLine] Destaque removido');
      }, 3000);
    } else {
      console.error('[goToLine] Elemento lineHighlightBg não encontrado!');
    }
    
    this.showNotification(`✓ Navegado para linha ${lineNumber}`, 'success');
  }
}

// ============================================================================
// LINTER UI - Integração Visual do Linter no Editor
// ============================================================================
class LaTeXLinterUI {
  constructor(editor) {
    this.editor = editor;
    this.lintMarkers = [];
    this.lintTimeout = null;
    this.isLinting = false;
    this.currentErrors = [];
    this.currentWarnings = [];
    
    // Adicionar listener para verificar enquanto digita
    this.editor.addEventListener('input', () => this.scheduleLint());
    
    // Nota: O listener de scroll está no LaTeXEditor para evitar duplicação
  }
  
  scheduleLint() {
    // Debounce: esperar 2 segundos após parar de digitar
    clearTimeout(this.lintTimeout);
    this.lintTimeout = setTimeout(() => this.runLint(), 2000);
  }
  
  async runLint() {
    if (this.isLinting) return;
    this.isLinting = true;
    
    try {
      const content = this.editor.value;
      if (!content.trim()) {
        this.clearMarkers();
        this.isLinting = false;
        return;
      }
      
      const response = await fetch('/api/lint', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      });
      
      if (!response.ok) {
        console.error('Lint failed:', response.status);
        this.isLinting = false;
        return;
      }
      
      const data = await response.json();
      this.displayLintResults(data);
      
    } catch (error) {
      console.error('Lint error:', error);
    } finally {
      this.isLinting = false;
    }
  }
  
  displayLintResults(data) {
    this.clearMarkers();
    
    const errors = data.errors || [];
    const warnings = data.warnings || [];
    
    const totalLines = this.editor.value.split('\n').length;
    const lineNumbersDiv = document.getElementById('lineNumbers');
    const lineNumberElements = lineNumbersDiv ? lineNumbersDiv.querySelectorAll('.line-number').length : 0;
    
    // IMPORTANTE: Verificar se números de linha estão sincronizados
    if (lineNumberElements !== totalLines) {
      console.warn(`[Linter] AVISO: Números de linha desatualizados! Editor: ${totalLines} linhas, números: ${lineNumberElements} elementos`);
      // Forçar atualização dos números de linha
      if (window.latexEditor) {
        window.latexEditor.updateLineNumbers();
        console.log('[Linter] Números de linha atualizados forçadamente');
        
        // Aguardar o DOM atualizar antes de criar marcadores
        setTimeout(() => this.createMarkersFromData(errors, warnings), 50);
        return;
      }
    }
    
    this.createMarkersFromData(errors, warnings);
  }
  
  createMarkersFromData(errors, warnings) {
    // Salvar erros e avisos para uso posterior (correções)
    this.currentErrors = errors;
    this.currentWarnings = warnings;
    
    // Agrupar por linha
    const issuesByLine = {};
    
    errors.forEach(err => {
      const line = err.line || 'global';
      if (!issuesByLine[line]) issuesByLine[line] = [];
      issuesByLine[line].push({ ...err, type: 'error' });
    });
    
    warnings.forEach(warn => {
      const line = warn.line || 'global';
      if (!issuesByLine[line]) issuesByLine[line] = [];
      issuesByLine[line].push({ ...warn, type: 'warning' });
    });
    
    // Criar marcadores para cada linha com erro
    Object.keys(issuesByLine).forEach(lineNum => {
      if (lineNum === 'global') return; // Ignorar erros globais por enquanto
      
      const issues = issuesByLine[lineNum];
      const hasError = issues.some(i => i.type === 'error');
      
      const lineNumInt = parseInt(lineNum);
      this.createLineMarker(lineNumInt, issues, hasError ? 'error' : 'warning');
    });
    
    // Atualizar contador na status bar (se existir)
    const errorCount = errors.length;
    const warningCount = warnings.length;
    
    if (errorCount > 0 || warningCount > 0) {
      console.log(`[Linter] ${errorCount} erros, ${warningCount} avisos`);
      
      // DEBUG: Listar todos os erros
      if (errorCount > 0) {
        console.log('[Linter] === ERROS DETECTADOS ===');
        errors.forEach((err, i) => {
          console.log(`  ${i+1}. Linha ${err.line || 'global'}: ${err.message}`);
        });
      }
      
      if (warningCount > 0) {
        console.log('[Linter] === AVISOS DETECTADOS ===');
        warnings.forEach((warn, i) => {
          console.log(`  ${i+1}. Linha ${warn.line || 'global'}: ${warn.message}`);
        });
      }
    }
    
    // Atualizar o card do Linter
    this.updateLintCard(errors, warnings);
  }
  
  updateLintCard(errors, warnings) {
    // Atualizar status
    const statusEl = document.getElementById('lintStatus');
    if (statusEl) {
      const total = errors.length + warnings.length;
      statusEl.textContent = `Completo: ${total} problemas`;
    }
    
    // Atualizar contadores
    const errorsCountEl = document.getElementById('lintErrors');
    const warningsCountEl = document.getElementById('lintWarnings');
    const suggestionsCountEl = document.getElementById('lintSuggestions');
    
    if (errorsCountEl) errorsCountEl.textContent = errors.length;
    if (warningsCountEl) warningsCountEl.textContent = warnings.length;
    if (suggestionsCountEl) {
      const suggestionsCount = [...errors, ...warnings].filter(i => i.suggestion).length;
      suggestionsCountEl.textContent = suggestionsCount;
    }
    
    // ===== ATUALIZAR BADGE E ABRIR AUTOMATICAMENTE =====
    const badge = document.getElementById('lintBadge');
    const toggle = document.getElementById('lintToggle');
    const panel = document.getElementById('lintPanel');
    const totalIssues = errors.length + warnings.length;
    
    if (totalIssues > 0) {
      // Mostrar badge
      if (badge) {
        badge.textContent = totalIssues > 99 ? '99+' : totalIssues;
        badge.style.display = 'flex';
      }
      
      // Animar botão
      if (toggle) {
        toggle.classList.add('has-errors');
        setTimeout(() => toggle.classList.remove('has-errors'), 500);
      }
      
      // Abrir painel automaticamente se estiver fechado
      if (panel && !panel.classList.contains('open')) {
        panel.classList.add('open');
        if (toggle) toggle.classList.add('active');
      }
    } else {
      // Esconder badge
      if (badge) {
        badge.style.display = 'none';
      }
    }
    
    // Atualizar lista de problemas
    const issuesEl = document.getElementById('lintIssues');
    if (issuesEl) {
      issuesEl.innerHTML = '';
      
      if (errors.length === 0 && warnings.length === 0) {
        issuesEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #2ecc71;">✅ Nenhum problema encontrado!</div>';
        return;
      }
      
      // Adicionar erros
      errors.forEach((err, index) => {
        const item = document.createElement('div');
        item.className = 'lint-issue-item';
        item.style.cssText = 'padding: 12px; margin-bottom: 8px; background: #ffebee; border-left: 4px solid #f44336; border-radius: 4px;';
        
        const actionsHtml = err.line ? `
          <div style="display: flex; gap: 8px; margin-top: 8px;">
            ${err.fix ? `<button onclick="window.linterUI.applyFix(${err.line}, 'error', ${index})" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
              ✨ Corrigir
            </button>` : ''}
            <button onclick="window.linterUI.goToLine(${err.line})" style="padding: 4px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
              → Ir para linha
            </button>
          </div>
        ` : '';
        
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <span style="font-weight: bold; color: #f44336;">❌ ${err.message}</span>
            ${err.line ? `<span style="color: #666; font-size: 0.9rem;">Linha ${err.line}</span>` : '<span style="color: #666; font-size: 0.9rem;">Global</span>'}
          </div>
          ${err.suggestion ? `<div style="color: #1976d2; font-size: 0.9rem; margin-top: 4px;">💡 ${err.suggestion}</div>` : ''}
          ${actionsHtml}
        `;
        issuesEl.appendChild(item);
      });
      
      // Adicionar avisos
      warnings.forEach((warn, index) => {
        const item = document.createElement('div');
        item.className = 'lint-issue-item';
        item.style.cssText = 'padding: 12px; margin-bottom: 8px; background: #fff3e0; border-left: 4px solid #ff9800; border-radius: 4px;';
        
        const actionsHtml = warn.line ? `
          <div style="display: flex; gap: 8px; margin-top: 8px;">
            ${warn.fix ? `<button onclick="window.linterUI.applyFix(${warn.line}, 'warning', ${index})" style="padding: 4px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
              ✨ Corrigir
            </button>` : ''}
            <button onclick="window.linterUI.goToLine(${warn.line})" style="padding: 4px 12px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
              → Ir para linha
            </button>
          </div>
        ` : '';
        
        item.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <span style="font-weight: bold; color: #ff9800;">⚠️ ${warn.message}</span>
            ${warn.line ? `<span style="color: #666; font-size: 0.9rem;">Linha ${warn.line}</span>` : '<span style="color: #666; font-size: 0.9rem;">Global</span>'}
          </div>
          ${warn.suggestion ? `<div style="color: #1976d2; font-size: 0.9rem; margin-top: 4px;">💡 ${warn.suggestion}</div>` : ''}
          ${actionsHtml}
        `;
        issuesEl.appendChild(item);
      });
    }
    
    // Esconder aviso de "documento desatualizado"
    const outdatedWarning = document.getElementById('lintOutdatedWarning');
    if (outdatedWarning) {
      outdatedWarning.style.display = 'none';
    }
    
    // Habilitar/desabilitar botão de "Aplicar Todas Correções"
    const fixAllBtn = document.getElementById('lintFixAllBtn');
    if (fixAllBtn) {
      const hasFixableIssues = [...errors, ...warnings].some(issue => issue.fix);
      fixAllBtn.disabled = !hasFixableIssues;
      fixAllBtn.style.opacity = hasFixableIssues ? '1' : '0.5';
      fixAllBtn.style.cursor = hasFixableIssues ? 'pointer' : 'not-allowed';
    }
  }
  
  createLineMarker(lineNum, issues, type) {
    const editorWrapper = this.editor.parentElement;
    
    // Calcular altura da linha
    const computedStyle = getComputedStyle(this.editor);
    let lineHeight = parseFloat(computedStyle.lineHeight);
    if (!lineHeight || isNaN(lineHeight)) {
      const fontSize = parseFloat(computedStyle.fontSize) || 14;
      lineHeight = fontSize * 1.5;
    }
    
    // Criar marcador de fundo
    const marker = document.createElement('div');
    marker.className = type === 'error' ? 'lint-error-marker' : 'lint-warning-marker';
    marker.dataset.lineNum = lineNum;
    marker.style.height = `${lineHeight}px`;
    
    // Criar ícone na margem
    const icon = document.createElement('div');
    icon.className = `lint-icon lint-icon-${type}`;
    icon.dataset.lineNum = lineNum;
    icon.innerHTML = type === 'error' ? '⚠️' : '⚡';
    icon.title = issues.map(i => i.message).join('\n');
    
    // Adicionar tooltip ao passar o mouse
    icon.addEventListener('mouseenter', (e) => this.showTooltip(e, issues, type));
    icon.addEventListener('mouseleave', () => this.hideTooltip());
    
    editorWrapper.appendChild(marker);
    editorWrapper.appendChild(icon);
    
    this.lintMarkers.push({ marker, icon, lineNum });
    
    // Posicionar inicialmente
    this.updateMarkerPosition(marker, icon, lineNum);
  }
  
  updateMarkerPosition(marker, icon, lineNum) {
    // Método NOVO: usar os números de linha como referência
    const lines = this.editor.value.split('\n');
    
    // Validar número de linha
    if (lineNum < 1 || lineNum > lines.length) {
      console.warn(`[Linter] Linha ${lineNum} fora do range (1-${lines.length})`);
      marker.style.display = 'none';
      icon.style.display = 'none';
      return;
    }
    
    marker.style.display = 'block';
    icon.style.display = 'block';
    
    // Buscar o elemento de número de linha correspondente
    const lineNumbersDiv = document.getElementById('lineNumbers');
    if (!lineNumbersDiv) {
      console.error('[Linter] lineNumbers div não encontrado!');
      return;
    }
    
    const lineNumberElements = lineNumbersDiv.querySelectorAll('.line-number');
    const targetLineElement = lineNumberElements[lineNum - 1]; // 0-based no array
    
    if (!targetLineElement) {
      console.warn(`[Linter] Elemento de número de linha ${lineNum} não encontrado`);
      return;
    }
    
    // Usar a posição REAL do elemento de número de linha
    const lineNumberRect = targetLineElement.getBoundingClientRect();
    const editorRect = this.editor.getBoundingClientRect();
    
    // Calcular posição relativa ao editor
    const top = lineNumberRect.top - editorRect.top;
    
    marker.style.top = `${top}px`;
    icon.style.top = `${top}px`;
  }
  
  updateAllMarkerPositions() {
    this.lintMarkers.forEach(item => {
      if (item.marker && item.icon && item.lineNum) {
        this.updateMarkerPosition(item.marker, item.icon, item.lineNum);
      }
    });
  }
  
  showTooltip(event, issues, type) {
    const tooltip = document.createElement('div');
    tooltip.className = 'lint-tooltip';
    tooltip.id = 'lintTooltip';
    
    let html = '';
    issues.forEach((issue, idx) => {
      if (idx > 0) html += '<hr style="margin: 8px 0; border-color: rgba(255,255,255,0.2);">';
      html += `<div class="lint-tooltip-title">${type === 'error' ? '❌' : '⚠️'} ${issue.message}</div>`;
      if (issue.suggestion) {
        html += `<div class="lint-tooltip-suggestion">💡 ${issue.suggestion}</div>`;
      }
    });
    
    tooltip.innerHTML = html;
    
    const rect = event.target.getBoundingClientRect();
    tooltip.style.left = `${rect.right + 10}px`;
    tooltip.style.top = `${rect.top}px`;
    
    document.body.appendChild(tooltip);
  }
  
  hideTooltip() {
    const tooltip = document.getElementById('lintTooltip');
    if (tooltip) tooltip.remove();
  }
  
  goToLine(lineNumber) {
    if (!lineNumber || lineNumber < 1) return;
    
    const lines = this.editor.value.split('\n');
    if (lineNumber > lines.length) return;
    
    // Calcular a posição do caractere
    let position = 0;
    for (let i = 0; i < lineNumber - 1; i++) {
      position += lines[i].length + 1; // +1 para o \n
    }
    
    // Mover cursor e scroll para a linha
    this.editor.focus();
    this.editor.setSelectionRange(position, position + lines[lineNumber - 1].length);
    
    // Scroll para garantir que a linha está visível
    const lineHeight = parseFloat(getComputedStyle(this.editor).lineHeight) || 20;
    this.editor.scrollTop = (lineNumber - 5) * lineHeight; // -5 para deixar contexto
    
    console.log(`[Linter] Navegado para linha ${lineNumber}`);
  }
  
  async applyFix(lineNumber, type, index) {
    const issue = type === 'error' ? this.currentErrors[index] : this.currentWarnings[index];
    
    if (!issue || !issue.fix) {
      console.warn(`[Linter] Nenhuma correção disponível para ${type} na linha ${lineNumber}`);
      return;
    }
    
    const lines = this.editor.value.split('\n');
    if (lineNumber < 1 || lineNumber > lines.length) {
      console.error(`[Linter] Linha ${lineNumber} inválida`);
      return;
    }
    
    // Aplicar correção na linha
    lines[lineNumber - 1] = issue.fix;
    this.editor.value = lines.join('\n');
    
    // Atualizar interface
    if (window.latexEditor) {
      window.latexEditor.updateLineNumbers();
      window.latexEditor.updateStatus();
    }
    
    // Reexecutar lint após 500ms
    setTimeout(() => this.runLint(), 500);
    
    console.log(`[Linter] Correção aplicada na linha ${lineNumber}`);
  }
  
  async applyAllFixes() {
    const allIssues = [
      ...this.currentErrors.map((e, i) => ({ ...e, type: 'error', index: i })),
      ...this.currentWarnings.map((w, i) => ({ ...w, type: 'warning', index: i }))
    ];
    
    const fixableIssues = allIssues.filter(issue => issue.fix && issue.line);
    
    if (fixableIssues.length === 0) {
      return;
    }
    
    // Aplicar correções de trás para frente para não afetar números de linha
    fixableIssues.sort((a, b) => b.line - a.line);
    
    const lines = this.editor.value.split('\n');
    fixableIssues.forEach(issue => {
      if (issue.line >= 1 && issue.line <= lines.length) {
        lines[issue.line - 1] = issue.fix;
      }
    });
    
    this.editor.value = lines.join('\n');
    
    // Atualizar interface
    if (window.latexEditor) {
      window.latexEditor.updateLineNumbers();
      window.latexEditor.updateStatus();
    }
    
    // Reexecutar lint
    setTimeout(() => this.runLint(), 500);
    
    console.log(`[Linter] ${fixableIssues.length} correções aplicadas`);
  }
  
  clearMarkers() {
    this.lintMarkers.forEach(item => {
      if (item.marker) item.marker.remove();
      if (item.icon) item.icon.remove();
    });
    this.lintMarkers = [];
    this.hideTooltip();
  }
}

// Função para inicializar o Linter UI
function initializeLinterUI() {
  const editorElement = document.getElementById('latexEditor');
  if (editorElement && !window.linterUI) {
    window.linterUI = new LaTeXLinterUI(editorElement);
    console.log('[Linter] Integração visual ativada');
    return true;
  }
  return false;
}

// Inicializar editor quando a página carregar
document.addEventListener('DOMContentLoaded', () => {
  window.latexEditor = new LaTeXEditor();
  
  // Inicializar Linter UI
  initializeLinterUI();
});

// Funções globais para os botões
function saveDocument() { 
  window.latexEditor.saveDocument(); 
  openFileManager(); // Abrir gerenciador após salvar
}
function newDocument() { 
  window.latexEditor.newDocument(); 
  openFileManager(); // Abrir gerenciador após criar novo
}
function createNewFile() { 
  window.latexEditor.newDocument(); 
  openFileManager(); // Abrir gerenciador após criar novo
}
function openDocument() { window.latexEditor.openDocument(); }
function uploadImage() { window.latexEditor.uploadImage(); }
function undoAction() { window.latexEditor.undoAction(); }
function redoAction() { window.latexEditor.redoAction(); }
function formatText(type) { window.latexEditor.formatText(type); }
function createFolder() { window.latexEditor.createFolder(); }
function insertSnippet(type) { window.latexEditor.insertSnippet(type); }
function compileDocument() { window.latexEditor.compileDocument(); }
function previewDocument() { window.latexEditor.previewDocument(); }
function closeTab(fileName) { window.latexEditor.closeTab(fileName); }

// Função para abrir o gerenciador de arquivos na pasta root do sistema
function openFileManager() {
  // Caminho para a pasta root do sistema (onde está o DocCollab)
  const rootPath = window.location.origin.replace('http://localhost:5000', 'D:\\OurDocs\\DocCollab');
  
  // Tentar abrir o gerenciador de arquivos diretamente
  try {
    // Para Windows - usar comando direto
    if (navigator.platform.indexOf('Win') !== -1) {
      // Usar fetch para chamar a API do backend
      fetch('/api/open-file-manager', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ path: '.' }) // Pasta atual (root do sistema)
      }).then(response => {
        if (response.ok) {
          console.log('Gerenciador de arquivos aberto com sucesso');
        } else {
          throw new Error('Erro na API');
        }
      }).catch(err => {
        console.log('Erro ao abrir gerenciador via API:', err);
        // Fallback: mostrar instruções para o usuário
        alert('Abra manualmente o gerenciador de arquivos na pasta:\nD:\\OurDocs\\DocCollab');
      });
    } else {
      // Para outros sistemas, mostrar caminho
      alert(`Abra manualmente a pasta: ${rootPath}`);
    }
  } catch (error) {
    console.error('Erro ao abrir gerenciador:', error);
    alert('Abra manualmente o gerenciador de arquivos na pasta:\nD:\\OurDocs\\DocCollab');
  }
}

// Adicionar CSS para animações
const style = document.createElement('style');
style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes highlightPulse {
    0% { 
      opacity: 0;
      transform: scaleX(0.95);
    }
    10% { 
      opacity: 1;
      transform: scaleX(1);
    }
    90% { 
      opacity: 1;
      transform: scaleX(1);
    }
    100% { 
      opacity: 0;
      transform: scaleX(0.95);
    }
  }
  
  .line-highlight-overlay {
    transform-origin: left center;
  }
`;
document.head.appendChild(style);

// Adicionar CSS para o botão voltar
const backButtonStyle = document.createElement('style');
backButtonStyle.textContent = `
  .btn-back {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
    color: white !important;
    text-decoration: none !important;
    display: inline-flex !important;
    align-items: center !important;
    gap: 8px !important;
    font-weight: 600 !important;
  }
  
  .btn-back:hover {
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4) !important;
  }
  
  .btn-back i {
    font-size: 14px !important;
  }
`;
document.head.appendChild(backButtonStyle);
</script>

<!-- ============================================================================ -->
<!-- CHAT COLABORATIVO MODAL -->
<!-- ============================================================================ -->

<!-- Botão flutuante para abrir chat -->
<button id="chatToggleBtn" class="chat-toggle-btn" title="Chat Colaborativo" onclick="toggleChatModal()">
  <i class="fas fa-comments"></i>
  <span class="chat-notification-badge" id="chatNotificationBadge" style="display: none;">0</span>
</button>

<!-- Modal de Chat -->
<div id="chatModal" class="chat-modal">
  <div class="chat-modal-content">
    <!-- Sidebar: Lista de Grupos -->
    <div class="chat-sidebar">
      <div class="chat-sidebar-header">
        <h3><i class="fas fa-comments me-2"></i>Chat</h3>
        <button class="btn-close-sidebar" onclick="toggleChatModal()">&times;</button>
      </div>
      
      <div class="chat-sidebar-body">
        <button class="btn btn-success w-100 mb-3" onclick="showCreateGroupModal()">
          <i class="fas fa-plus me-2"></i>Criar Grupo
        </button>
        
        <input type="text" class="form-control mb-3" id="searchGroupsInput" placeholder="Buscar grupos..." onkeyup="filterGroups()">
        
        <div class="groups-list" id="groupsList">
          <div class="text-center text-muted py-4">
            <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
            <p>Carregando grupos...</p>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Área de Chat -->
    <div class="chat-main-area">
      <div id="chatEmpty" class="chat-empty-state">
        <i class="fas fa-comments fa-4x text-muted mb-3"></i>
        <h4>Selecione um grupo</h4>
        <p class="text-muted">Escolha um grupo ou crie um novo para começar</p>
      </div>
      
      <div id="chatActive" class="chat-active" style="display: none;">
        <!-- Header do Chat Ativo -->
        <div class="chat-header">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h5 class="mb-0" id="activeGroupName">Grupo</h5>
              <small class="text-muted" id="activeGroupMembers">0 membros</small>
            </div>
            <div class="btn-group">
              <button class="btn btn-sm btn-outline-secondary" onclick="showMembersManageModal()" title="Gerenciar Membros">
                <i class="fas fa-users"></i>
              </button>
              <button class="btn btn-sm btn-outline-secondary" onclick="showSearchMessagesModal()" title="Buscar Mensagens">
                <i class="fas fa-search"></i>
              </button>
            </div>
          </div>
        </div>
        
        <!-- Mensagens -->
        <div class="chat-messages" id="chatMessages">
          <div class="text-center py-4">
            <i class="fas fa-spinner fa-spin fa-2x mb-2"></i>
            <p>Carregando mensagens...</p>
          </div>
        </div>
        
        <!-- Input de Mensagem -->
        <div class="chat-input-area">
          <form id="chatMessageForm" onsubmit="sendChatMessage(event)">
            <div class="input-group">
              <button type="button" class="btn btn-outline-secondary" onclick="document.getElementById('chatFileInput').click()" title="Anexar arquivo">
                <i class="fas fa-paperclip"></i>
              </button>
              <input type="file" id="chatFileInput" style="display: none;" onchange="handleFileSelect(this.files[0])">
              <input type="text" class="form-control" id="chatMessageInput" placeholder="Digite sua mensagem..." autocomplete="off">
              <button type="submit" class="btn btn-primary">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </form>
          <div id="chatFilePreview" class="file-preview" style="display: none;"></div>
          <small class="text-muted">
            <i class="fas fa-info-circle"></i> Arraste arquivos aqui ou use o botão de anexo
          </small>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: Criar Grupo -->
<div class="modal fade" id="createGroupChatModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Criar Novo Grupo</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <form onsubmit="createChatGroup(event)">
        <div class="modal-body">
          <div class="mb-3">
            <label class="form-label">Nome do Grupo *</label>
            <input type="text" class="form-control" id="newGroupName" required>
          </div>
          <div class="mb-3">
            <label class="form-label">Descrição</label>
            <textarea class="form-control" id="newGroupDescription" rows="3"></textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-primary">Criar Grupo</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Modal: Gerenciar Membros -->
<div class="modal fade" id="manageMembersModal" tabindex="-1">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Gerenciar Membros</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label class="form-label">Adicionar Membro (por email)</label>
          <form onsubmit="addGroupMember(event)" class="input-group">
            <input type="email" class="form-control" id="addMemberEmail" placeholder="email@exemplo.com" required>
            <button type="submit" class="btn btn-primary">Adicionar</button>
          </form>
        </div>
        <hr>
        <h6>Membros Atuais:</h6>
        <div id="currentMembersList">
          <p class="text-muted">Carregando...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal: Buscar Mensagens -->
<div class="modal fade" id="searchMessagesModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Buscar Mensagens</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <input type="text" class="form-control mb-3" id="searchMessagesInput" placeholder="Digite para buscar..." onkeyup="searchMessages()">
        <div id="searchMessagesResults">
          <p class="text-muted text-center">Digite para buscar mensagens</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ============================================================================ -->
<!-- ESTILOS CSS DO CHAT COLABORATIVO -->
<!-- ============================================================================ -->
<style>
/* Botão flutuante para abrir chat */
.chat-toggle-btn {
  position: fixed;
  bottom: 30px;
  right: 30px;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
  color: white;
  border: none;
  font-size: 24px;
  box-shadow: 0 4px 20px rgba(0, 123, 255, 0.4);
  cursor: pointer;
  transition: all 0.3s ease;
  z-index: 1040;
  display: flex;
  align-items: center;
  justify-content: center;
}

.chat-toggle-btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 25px rgba(0, 123, 255, 0.6);
  background: linear-gradient(135deg, #0056b3 0%, #004085 100%);
}

.chat-notification-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background: #dc3545;
  color: white;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: bold;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}

/* Modal de Chat */
.chat-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1050;
  backdrop-filter: blur(4px);
  animation: fadeIn 0.3s ease;
}

.chat-modal.active {
  display: flex;
  align-items: center;
  justify-content: center;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.chat-modal-content {
  background: white;
  border-radius: 12px;
  width: 90%;
  max-width: 1200px;
  height: 85vh;
  display: flex;
  overflow: hidden;
  box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
  animation: slideUp 0.3s ease;
}

@keyframes slideUp {
  from { transform: translateY(30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Sidebar */
.chat-sidebar {
  width: 300px;
  background: #f8f9fa;
  border-right: 1px solid #dee2e6;
  display: flex;
  flex-direction: column;
}

.chat-sidebar-header {
  padding: 20px;
  background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-sidebar-header h3 {
  margin: 0;
  font-size: 1.3rem;
  font-weight: 600;
}

.btn-close-sidebar {
  background: none;
  border: none;
  color: white;
  font-size: 28px;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  line-height: 1;
  opacity: 0.8;
  transition: opacity 0.3s;
}

.btn-close-sidebar:hover {
  opacity: 1;
}

.chat-sidebar-body {
  padding: 15px;
  flex: 1;
  overflow-y: auto;
}

.groups-list {
  max-height: calc(100% - 100px);
  overflow-y: auto;
}

.group-item {
  padding: 12px 15px;
  margin-bottom: 8px;
  border-radius: 8px;
  cursor: pointer;
  background: white;
  border: 1px solid #dee2e6;
  transition: all 0.2s ease;
  position: relative;
}

.group-item:hover {
  background: #e9ecef;
  border-color: #007bff;
  transform: translateX(3px);
}

.group-item.active {
  background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
  color: white;
  border-color: #007bff;
}

.group-item .group-name {
  font-weight: 600;
  font-size: 0.95rem;
  margin-bottom: 2px;
}

.group-item .group-description {
  font-size: 0.8rem;
  opacity: 0.8;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.group-item .notification-dot {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 10px;
  height: 10px;
  background: #007bff;
  border-radius: 50%;
  animation: pulse 2s infinite;
}

.group-item.active .notification-dot {
  background: white;
}

/* Área Principal do Chat */
.chat-main-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
}

.chat-empty-state {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

.chat-active {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.chat-header {
  padding: 20px;
  background: white;
  border-bottom: 1px solid #dee2e6;
}

.chat-messages {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
  background: #f8f9fa;
}

.message-item {
  margin-bottom: 15px;
  display: flex;
  flex-direction: column;
  animation: messageSlide 0.3s ease;
}

@keyframes messageSlide {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.message-item.own {
  align-items: flex-end;
}

.message-bubble {
  max-width: 70%;
  padding: 10px 15px;
  border-radius: 12px;
  background: white;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  position: relative;
}

.message-item.own .message-bubble {
  background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
  color: white;
}

.message-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 5px;
  font-size: 0.85rem;
}

.message-sender {
  font-weight: 600;
}

.message-time {
  opacity: 0.7;
  font-size: 0.75rem;
}

.message-content {
  word-wrap: break-word;
}

.message-file {
  margin-top: 8px;
  padding: 8px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.message-item.own .message-file {
  background: rgba(255, 255, 255, 0.2);
}

.file-thumbnail {
  width: 40px;
  height: 40px;
  object-fit: cover;
  border-radius: 4px;
}

.file-icon {
  font-size: 24px;
  opacity: 0.7;
}

.file-info {
  flex: 1;
}

.file-name {
  font-size: 0.85rem;
  font-weight: 500;
}

.file-size {
  font-size: 0.75rem;
  opacity: 0.7;
}

/* Input de Mensagem */
.chat-input-area {
  padding: 20px;
  background: white;
  border-top: 1px solid #dee2e6;
}

.file-preview {
  margin-bottom: 10px;
  padding: 10px;
  background: #f8f9fa;
  border-radius: 6px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.file-preview img {
  max-width: 60px;
  max-height: 60px;
  border-radius: 4px;
}

.file-preview .btn-remove {
  margin-left: auto;
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 0.8rem;
}

/* Drag and Drop */
.chat-input-area.drag-over {
  background: #e7f3ff;
  border-color: #007bff;
}

/* Responsividade */
@media (max-width: 768px) {
  .chat-modal-content {
    width: 100%;
    height: 100vh;
    border-radius: 0;
  }
  
  .chat-sidebar {
    width: 100%;
    position: absolute;
    height: 100%;
    z-index: 10;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
  }
  
  .chat-sidebar.mobile-visible {
    transform: translateX(0);
  }
  
  .message-bubble {
    max-width: 85%;
  }
}

/* Scrollbar personalizada */
.chat-messages::-webkit-scrollbar,
.groups-list::-webkit-scrollbar,
.chat-sidebar-body::-webkit-scrollbar {
  width: 8px;
}

.chat-messages::-webkit-scrollbar-track,
.groups-list::-webkit-scrollbar-track,
.chat-sidebar-body::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.chat-messages::-webkit-scrollbar-thumb,
.groups-list::-webkit-scrollbar-thumb,
.chat-sidebar-body::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

.chat-messages::-webkit-scrollbar-thumb:hover,
.groups-list::-webkit-scrollbar-thumb:hover,
.chat-sidebar-body::-webkit-scrollbar-thumb:hover {
  background: #555;
}
</style>

<!-- ============================================================================ -->
<!-- JAVASCRIPT DO CHAT COLABORATIVO -->
<!-- ============================================================================ -->
<script>
// ========== GERENCIADOR DO CHAT MODAL ==========
class ChatManager {
  constructor() {
    this.activeGroupId = null;
    this.currentUserId = null;
    this.groups = [];
    this.messages = [];
    this.pollingInterval = null;
    this.selectedFile = null;
    this.unreadCounts = {};
    this.lastMessageIds = {};
  }

  init() {
    console.log('[Chat] Inicializando...');
    this.setupDragAndDrop();
    this.loadCurrentUser();
  }

  async loadCurrentUser() {
    // Assumir que o usuário está logado (informação vem do Flask/session)
    this.currentUserId = {{ current_user.id }};
    console.log('[Chat] User ID:', this.currentUserId);
  }

  async loadGroups() {
    try {
      const response = await fetch('/api/groups');
      const data = await response.json();
      
      if (data.success) {
        this.groups = data.groups;
        this.renderGroupsList();
      }
    } catch (error) {
      console.error('[Chat] Erro ao carregar grupos:', error);
    }
  }

  renderGroupsList() {
    const container = document.getElementById('groupsList');
    
    if (this.groups.length === 0) {
      container.innerHTML = `
        <div class="text-center text-muted py-4">
          <i class="fas fa-inbox fa-2x mb-2"></i>
          <p>Nenhum grupo ainda</p>
          <small>Crie seu primeiro grupo!</small>
        </div>
      `;
      return;
    }

    container.innerHTML = this.groups.map(group => {
      const unread = this.unreadCounts[group.id] || 0;
      const notificationDot = unread > 0 ? '<span class="notification-dot"></span>' : '';
      
      return `
        <div class="group-item ${this.activeGroupId === group.id ? 'active' : ''}" 
             onclick="chatManager.selectGroup(${group.id})"
             data-group-id="${group.id}">
          ${notificationDot}
          <div class="group-name">${this.escapeHtml(group.name)}</div>
          <div class="group-description">${this.escapeHtml(group.description || 'Sem descrição')}</div>
        </div>
      `;
    }).join('');
  }

  async selectGroup(groupId) {
    console.log('[Chat] Selecionando grupo:', groupId);
    this.activeGroupId = groupId;
    
    // Atualizar UI
    this.renderGroupsList();
    document.getElementById('chatEmpty').style.display = 'none';
    document.getElementById('chatActive').style.display = 'flex';
    
    // Carregar informações do grupo
    const group = this.groups.find(g => g.id === groupId);
    if (group) {
      document.getElementById('activeGroupName').textContent = group.name;
      await this.loadGroupMembers(groupId);
    }
    
    // Carregar mensagens
    await this.loadMessages();
    
    // Iniciar polling
    this.startPolling();
    
    // Marcar como lido
    this.unreadCounts[groupId] = 0;
    this.updateNotificationBadge();
  }

  async loadGroupMembers(groupId) {
    try {
      const response = await fetch(`/api/groups/${groupId}/members`);
      const data = await response.json();
      
      if (data.success) {
        document.getElementById('activeGroupMembers').textContent = 
          `${data.members.length} membro${data.members.length !== 1 ? 's' : ''}`;
      }
    } catch (error) {
      console.error('[Chat] Erro ao carregar membros:', error);
    }
  }

  async loadMessages() {
    if (!this.activeGroupId) return;
    
    try {
      const response = await fetch(`/api/groups/${this.activeGroupId}/messages`);
      const data = await response.json();
      
      if (data.success) {
        this.messages = data.messages;
        this.renderMessages();
        
        // Marcar último ID
        if (this.messages.length > 0) {
          this.lastMessageIds[this.activeGroupId] = this.messages[this.messages.length - 1].id;
        }
      }
    } catch (error) {
      console.error('[Chat] Erro ao carregar mensagens:', error);
    }
  }

  renderMessages() {
    const container = document.getElementById('chatMessages');
    
    if (this.messages.length === 0) {
      container.innerHTML = `
        <div class="text-center text-muted py-4">
          <i class="fas fa-comment-slash fa-2x mb-2"></i>
          <p>Nenhuma mensagem ainda</p>
          <small>Seja o primeiro a enviar!</small>
        </div>
      `;
      return;
    }

    container.innerHTML = this.messages.map(msg => {
      const isOwn = msg.user_id === this.currentUserId;
      const time = this.formatTime(msg.created_at);
      
      let fileHtml = '';
      if (msg.file_path) {
        const fileName = msg.file_path.split('/').pop();
        const isImage = /\.(jpg|jpeg|png|gif|webp)$/i.test(fileName);
        
        if (isImage) {
          fileHtml = `
            <div class="message-file">
              <img src="${msg.file_path}" class="file-thumbnail" alt="${fileName}">
              <div class="file-info">
                <div class="file-name">${fileName}</div>
                <a href="${msg.file_path}" target="_blank" class="btn btn-sm btn-link p-0">
                  <i class="fas fa-download"></i> Download
                </a>
              </div>
            </div>
          `;
        } else {
          fileHtml = `
            <div class="message-file">
              <i class="fas fa-file file-icon"></i>
              <div class="file-info">
                <div class="file-name">${fileName}</div>
                <a href="${msg.file_path}" target="_blank" class="btn btn-sm btn-link p-0">
                  <i class="fas fa-download"></i> Download
                </a>
              </div>
            </div>
          `;
        }
      }
      
      return `
        <div class="message-item ${isOwn ? 'own' : ''}">
          <div class="message-bubble">
            <div class="message-header">
              <span class="message-sender">${this.escapeHtml(msg.username)}</span>
              <span class="message-time">${time}</span>
            </div>
            ${msg.content ? `<div class="message-content">${this.escapeHtml(msg.content)}</div>` : ''}
            ${fileHtml}
          </div>
        </div>
      `;
    }).join('');
    
    // Scroll para o final
    setTimeout(() => container.scrollTop = container.scrollHeight, 100);
  }

  async sendMessage(content, file = null) {
    if (!this.activeGroupId) return;
    if (!content && !file) return;
    
    const formData = new FormData();
    if (content) formData.append('content', content);
    if (file) formData.append('file', file);
    
    try {
      const response = await fetch(`/api/groups/${this.activeGroupId}/messages/send`, {
        method: 'POST',
        body: formData
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Recarregar mensagens
        await this.loadMessages();
      } else {
        alert('Erro ao enviar mensagem: ' + (data.error || 'Erro desconhecido'));
      }
    } catch (error) {
      console.error('[Chat] Erro ao enviar mensagem:', error);
      alert('Erro ao enviar mensagem');
    }
  }

  startPolling() {
    if (this.pollingInterval) clearInterval(this.pollingInterval);
    
    this.pollingInterval = setInterval(async () => {
      if (this.activeGroupId) {
        await this.checkNewMessages();
      }
    }, 3000); // Polling a cada 3 segundos
  }

  async checkNewMessages() {
    if (!this.activeGroupId) return;
    
    const lastId = this.lastMessageIds[this.activeGroupId] || 0;
    
    try {
      const response = await fetch(`/api/groups/${this.activeGroupId}/messages?since=${lastId}`);
      const data = await response.json();
      
      if (data.success && data.messages.length > 0) {
        // Adicionar novas mensagens
        this.messages = [...this.messages, ...data.messages];
        this.renderMessages();
        this.lastMessageIds[this.activeGroupId] = data.messages[data.messages.length - 1].id;
      }
    } catch (error) {
      console.error('[Chat] Erro no polling:', error);
    }
  }

  setupDragAndDrop() {
    const inputArea = document.querySelector('.chat-input-area');
    if (!inputArea) return;
    
    inputArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      inputArea.classList.add('drag-over');
    });
    
    inputArea.addEventListener('dragleave', () => {
      inputArea.classList.remove('drag-over');
    });
    
    inputArea.addEventListener('drop', (e) => {
      e.preventDefault();
      inputArea.classList.remove('drag-over');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        this.handleFileSelect(files[0]);
      }
    });
  }

  handleFileSelect(file) {
    if (!file) return;
    
    // Limite de 10MB
    if (file.size > 10 * 1024 * 1024) {
      alert('Arquivo muito grande! Máximo: 10MB');
      return;
    }
    
    this.selectedFile = file;
    this.showFilePreview(file);
  }

  showFilePreview(file) {
    const preview = document.getElementById('chatFilePreview');
    const isImage = file.type.startsWith('image/');
    
    let html = '<div>';
    if (isImage) {
      const reader = new FileReader();
      reader.onload = (e) => {
        preview.innerHTML = `
          <img src="${e.target.result}" alt="${file.name}">
          <div class="file-info">
            <div class="file-name">${file.name}</div>
            <div class="file-size">${this.formatFileSize(file.size)}</div>
          </div>
          <button class="btn-remove" onclick="chatManager.clearFileSelection()">
            <i class="fas fa-times"></i>
          </button>
        `;
      };
      reader.readAsDataURL(file);
    } else {
      preview.innerHTML = `
        <i class="fas fa-file file-icon"></i>
        <div class="file-info">
          <div class="file-name">${file.name}</div>
          <div class="file-size">${this.formatFileSize(file.size)}</div>
        </div>
        <button class="btn-remove" onclick="chatManager.clearFileSelection()">
          <i class="fas fa-times"></i>
        </button>
      `;
    }
    
    preview.style.display = 'flex';
  }

  clearFileSelection() {
    this.selectedFile = null;
    document.getElementById('chatFilePreview').style.display = 'none';
    document.getElementById('chatFileInput').value = '';
  }

  updateNotificationBadge() {
    const total = Object.values(this.unreadCounts).reduce((a, b) => a + b, 0);
    const badge = document.getElementById('chatNotificationBadge');
    
    if (total > 0) {
      badge.textContent = total > 99 ? '99+' : total;
      badge.style.display = 'flex';
    } else {
      badge.style.display = 'none';
    }
  }

  formatTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'agora';
    if (diff < 3600000) return Math.floor(diff / 60000) + ' min';
    if (diff < 86400000) return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
  }

  formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / 1048576).toFixed(1) + ' MB';
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Instância global
const chatManager = new ChatManager();

// ========== FUNÇÕES GLOBAIS DO CHAT ==========
function toggleChatModal() {
  const modal = document.getElementById('chatModal');
  const isActive = modal.classList.contains('active');
  
  if (isActive) {
    modal.classList.remove('active');
    if (chatManager.pollingInterval) {
      clearInterval(chatManager.pollingInterval);
      chatManager.pollingInterval = null;
    }
  } else {
    modal.classList.add('active');
    chatManager.loadGroups();
  }
}

function showCreateGroupModal() {
  const modal = new bootstrap.Modal(document.getElementById('createGroupChatModal'));
  modal.show();
}

async function createChatGroup(e) {
  e.preventDefault();
  
  const name = document.getElementById('newGroupName').value.trim();
  const description = document.getElementById('newGroupDescription').value.trim();
  
  if (!name) {
    alert('Nome do grupo é obrigatório');
    return;
  }
  
  try {
    const response = await fetch('/api/groups/create', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description })
    });
    
    const data = await response.json();
    
    if (data.success) {
      bootstrap.Modal.getInstance(document.getElementById('createGroupChatModal')).hide();
      document.getElementById('newGroupName').value = '';
      document.getElementById('newGroupDescription').value = '';
      
      // Recarregar grupos
      await chatManager.loadGroups();
      
      // Auto-selecionar o novo grupo
      if (data.group_id) {
        setTimeout(() => chatManager.selectGroup(data.group_id), 300);
      }
    } else {
      alert('Erro: ' + (data.error || 'Erro desconhecido'));
    }
  } catch (error) {
    console.error('[Chat] Erro ao criar grupo:', error);
    alert('Erro ao criar grupo');
  }
}

function sendChatMessage(e) {
  e.preventDefault();
  
  const input = document.getElementById('chatMessageInput');
  const content = input.value.trim();
  const file = chatManager.selectedFile;
  
  if (!content && !file) return;
  
  chatManager.sendMessage(content, file);
  
  input.value = '';
  chatManager.clearFileSelection();
}

function handleFileSelect(file) {
  chatManager.handleFileSelect(file);
}

function filterGroups() {
  const search = document.getElementById('searchGroupsInput').value.toLowerCase();
  const items = document.querySelectorAll('.group-item');
  
  items.forEach(item => {
    const name = item.querySelector('.group-name').textContent.toLowerCase();
    const desc = item.querySelector('.group-description').textContent.toLowerCase();
    
    if (name.includes(search) || desc.includes(search)) {
      item.style.display = 'block';
    } else {
      item.style.display = 'none';
    }
  });
}

async function showMembersManageModal() {
  const modal = new bootstrap.Modal(document.getElementById('manageMembersModal'));
  modal.show();
  
  // Carregar membros atuais
  if (chatManager.activeGroupId) {
    try {
      const response = await fetch(`/api/groups/${chatManager.activeGroupId}/members`);
      const data = await response.json();
      
      if (data.success) {
        const container = document.getElementById('currentMembersList');
        container.innerHTML = data.members.map(member => `
          <div class="d-flex justify-content-between align-items-center mb-2 p-2 border rounded">
            <div>
              <strong>${member.username}</strong>
              <small class="text-muted ms-2">(${member.role})</small>
            </div>
            ${member.role !== 'leader' ? `
              <button class="btn btn-sm btn-danger" onclick="removeMember(${member.id})">
                <i class="fas fa-trash"></i>
              </button>
            ` : ''}
          </div>
        `).join('');
      }
    } catch (error) {
      console.error('[Chat] Erro ao carregar membros:', error);
    }
  }
}

async function addGroupMember(e) {
  e.preventDefault();
  
  const email = document.getElementById('addMemberEmail').value.trim();
  
  if (!email || !chatManager.activeGroupId) return;
  
  try {
    const response = await fetch(`/api/groups/${chatManager.activeGroupId}/members/add`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    
    const data = await response.json();
    
    if (data.success) {
      document.getElementById('addMemberEmail').value = '';
      showMembersManageModal(); // Recarregar lista
      await chatManager.loadGroupMembers(chatManager.activeGroupId);
    } else {
      alert('Erro: ' + (data.error || 'Erro desconhecido'));
    }
  } catch (error) {
    console.error('[Chat] Erro ao adicionar membro:', error);
    alert('Erro ao adicionar membro');
  }
}

async function removeMember(userId) {
  if (!confirm('Remover este membro do grupo?')) return;
  
  try {
    const response = await fetch(`/api/groups/${chatManager.activeGroupId}/members/${userId}/remove`, {
      method: 'POST'
    });
    
    const data = await response.json();
    
    if (data.success) {
      showMembersManageModal(); // Recarregar lista
      await chatManager.loadGroupMembers(chatManager.activeGroupId);
    } else {
      alert('Erro: ' + (data.error || 'Erro desconhecido'));
    }
  } catch (error) {
    console.error('[Chat] Erro ao remover membro:', error);
    alert('Erro ao remover membro');
  }
}

function showSearchMessagesModal() {
  const modal = new bootstrap.Modal(document.getElementById('searchMessagesModal'));
  modal.show();
}

async function searchMessages() {
  const query = document.getElementById('searchMessagesInput').value.trim();
  const resultsContainer = document.getElementById('searchMessagesResults');
  
  if (!query || !chatManager.activeGroupId) {
    resultsContainer.innerHTML = '<p class="text-muted text-center">Digite para buscar mensagens</p>';
    return;
  }
  
  try {
    const response = await fetch(`/api/groups/${chatManager.activeGroupId}/messages/search?q=${encodeURIComponent(query)}`);
    const data = await response.json();
    
    if (data.success) {
      if (data.results.length === 0) {
        resultsContainer.innerHTML = '<p class="text-muted text-center">Nenhum resultado encontrado</p>';
      } else {
        resultsContainer.innerHTML = data.results.map(msg => `
          <div class="border-bottom pb-2 mb-2">
            <div class="d-flex justify-content-between">
              <strong>${msg.username}</strong>
              <small class="text-muted">${chatManager.formatTime(msg.created_at)}</small>
            </div>
            <p class="mb-0">${chatManager.escapeHtml(msg.content)}</p>
          </div>
        `).join('');
      }
    }
  } catch (error) {
    console.error('[Chat] Erro na busca:', error);
  }
}

// Inicializar quando carregar
document.addEventListener('DOMContentLoaded', () => {
  chatManager.init();
});
</script>

<!-- ASSISTENTE LATEX REMOVIDO - Substituído por Chat Colaborativo em Grupos -->
<!--
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
// Gerenciador do Assistente Virtual com Socket.IO
class AssistantManager {
  constructor() {
    this.socket = null;
    this.actions = new Map(); // Map<action_id, action_data>
    this.init();
  }
  
  init() {
    // Conectar ao Socket.IO
    this.socket = io({
      transports: ['websocket', 'polling']
    });
    
    // Event listeners
    this.socket.on('connect', () => {
      console.log('[Assistant] Conectado ao servidor', this.socket.id);
      this.addSystemMessage('✅ Conectado ao servidor');
    });
    
    this.socket.on('disconnect', () => {
      console.log('[Assistant] Desconectado do servidor');
      this.addSystemMessage('⚠️ Desconectado. Reconectando...');
    });
    
    this.socket.on('connection_status', (data) => {
      console.log('[Assistant] Status:', data);
    });
    
    this.socket.on('assistant_response', (data) => {
      this.addAssistantMessage(data.content);
    });
    
    this.socket.on('assistant_action_confirmed', (data) => {
      this.updateActionState(data.action_id, 'confirmed', data.message);
    });
    
    this.socket.on('assistant_action_reverted', (data) => {
      this.updateActionState(data.action_id, 'reverted', data.message);
    });
    
    this.socket.on('assistant_error', (data) => {
      this.addSystemMessage(`❌ Erro: ${data.message}`, 'error');
    });
  }
  
  // Enviar mensagem de chat
  sendMessage(content) {
    const message_id = this.generateId();
    
    // Adicionar mensagem do usuário
    this.addUserMessage(content);
    
    // Enviar para servidor com callback (ack)
    this.socket.emit('assistant_message', 
      { message_id, content },
      (response) => {
        console.log('[Assistant] Mensagem confirmada:', response);
      }
    );
  }
  
  // Enviar ação (com Optimistic UI)
  sendAction(action_type, payload) {
    const action_id = this.generateId();
    
    // Aplicar localmente PRIMEIRO (Optimistic UI)
    this.applyActionLocally(action_id, action_type, payload);
    
    // Criar objeto de ação
    const action = {
      action_id,
      action_type,
      payload,
      state: 'applied_local'
    };
    
    // Armazenar ação
    this.actions.set(action_id, action);
    
    // Mostrar badge de estado
    this.addActionMessage(action_id, action_type, 'applied_local');
    
    // Enviar para servidor com callback e timeout
    let responseReceived = false;
    
    this.socket.emit('assistant_action', action, (response) => {
      responseReceived = true;
      console.log('[Assistant] Ação processada:', response);
      if (response && response.state) {
        this.updateActionState(action_id, response.state, response.message);
      } else {
        console.error('[Assistant] Resposta inválida:', response);
        this.updateActionState(action_id, 'error', 'Resposta inválida do servidor');
      }
    });
    
    // Timeout de 5 segundos
    setTimeout(() => {
      if (!responseReceived) {
        console.warn('[Assistant] Timeout esperando resposta para ação:', action_id);
        this.updateActionState(action_id, 'error', 'Timeout - servidor não respondeu');
      }
    }, 5000);
  }
  
  // Aplicar ação localmente (Optimistic UI)
  applyActionLocally(action_id, action_type, payload) {
    console.log('[Assistant] Aplicando localmente:', action_type, payload);
    
    // Exemplo: inserir snippet
    if (action_type === 'insert_snippet' && window.latexEditor) {
      const editor = window.latexEditor.editor;
      const snippet = payload.snippet || '';
      
      const pos = editor.selectionStart;
      const value = editor.value;
      editor.value = value.substring(0, pos) + snippet + value.substring(pos);
      editor.selectionStart = editor.selectionEnd = pos + snippet.length;
      
      window.latexEditor.updateLineNumbers();
      window.latexEditor.updateStatus();
    }
  }
  
  // Atualizar estado da ação
  updateActionState(action_id, new_state, message) {
    const action = this.actions.get(action_id);
    if (!action) return;
    
    action.state = new_state;
    
    // Atualizar badge visual
    const badge = document.querySelector(`[data-action-id="${action_id}"]`);
    if (badge) {
      badge.className = `action-badge state-${new_state}`;
      badge.textContent = this.getStateBadgeText(new_state);
      badge.title = message || new_state;
    }
    
    // Se revertido, desfazer ação local
    if (new_state === 'reverted') {
      this.revertActionLocally(action_id);
      this.addSystemMessage(`⚠️ Ação revertida: ${message}`, 'warning');
    }
  }
  
  // Reverter ação localmente
  revertActionLocally(action_id) {
    // TODO: Implementar undo real
    console.log('[Assistant] Revertendo ação:', action_id);
  }
  
  // Adicionar mensagem do usuário
  addUserMessage(content) {
    const messagesDiv = document.getElementById('assistantMessages');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'assistant-message user';
    msgDiv.innerHTML = `
      <div class="message-content">
        <p>${this.escapeHtml(content)}</p>
      </div>
    `;
    messagesDiv.appendChild(msgDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  // Adicionar mensagem do assistente
  addAssistantMessage(content) {
    const messagesDiv = document.getElementById('assistantMessages');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'assistant-message assistant';
    msgDiv.innerHTML = `
      <div class="message-content">
        <p>${this.escapeHtml(content)}</p>
      </div>
    `;
    messagesDiv.appendChild(msgDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  // Adicionar mensagem de sistema
  addSystemMessage(content, type = 'info') {
    const messagesDiv = document.getElementById('assistantMessages');
    const msgDiv = document.createElement('div');
    msgDiv.className = `assistant-message system ${type}`;
    msgDiv.innerHTML = `
      <div class="message-content">
        <p>${this.escapeHtml(content)}</p>
      </div>
    `;
    messagesDiv.appendChild(msgDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  // Adicionar mensagem de ação com badge de estado
  addActionMessage(action_id, action_type, state) {
    const messagesDiv = document.getElementById('assistantMessages');
    const msgDiv = document.createElement('div');
    msgDiv.className = 'assistant-message action';
    msgDiv.innerHTML = `
      <div class="message-content">
        <p>🔧 Ação: ${action_type}</p>
        <span class="action-badge state-${state}" data-action-id="${action_id}" title="${state}">
          ${this.getStateBadgeText(state)}
        </span>
      </div>
    `;
    messagesDiv.appendChild(msgDiv);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }
  
  // Texto do badge por estado
  getStateBadgeText(state) {
    const badges = {
      'pending': '⏳ Pendente',
      'applied_local': '📝 Aplicado',
      'confirmed': '✅ Confirmado',
      'reverted': '❌ Revertido',
      'error': '⚠️ Erro'
    };
    return badges[state] || state;
  }
  
  // Gerar ID único
  generateId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  // Escapar HTML
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Instanciar assistente
const assistant = new AssistantManager();

// Funções globais
function toggleAssistant() {
  const panel = document.getElementById('assistantPanel');
  const toggle = document.getElementById('assistantToggle');
  panel.classList.toggle('open');
  toggle.classList.toggle('active');
}

function sendAssistantMessage() {
  const input = document.getElementById('assistantInput');
  const content = input.value.trim();
  
  if (!content) return;
  
  assistant.sendMessage(content);
  input.value = '';
}

// Exemplo de comando: inserir snippet
function insertSnippetViaAssistant(snippet) {
  assistant.sendAction('insert_snippet', { snippet });
}

// Função global para gerar BibTeX
async function generateBibTeX(description) {
  if (!description) {
    description = prompt('Digite a descrição da referência:\n\nFormato: "Título, Autor, Ano, Editora"\nExemplo: "Deep Learning, Ian Goodfellow, 2016, MIT Press"');
    if (!description) return;
  }
  
  try {
    // Obter .bib existente
    const bibResponse = await fetch('/api/bib-file');
    const bibData = await bibResponse.json();
    const existingBib = bibData.content || '';
    
    // Gerar BibTeX
    const response = await fetch('/api/generate-bibtex', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        description: description,
        existing_bib: existingBib
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      // Mostrar diálogo de confirmação
      showBibTeXConfirmDialog(data);
    } else {
      alert('Erro ao gerar BibTeX: ' + (data.error || 'Erro desconhecido'));
    }
  } catch (error) {
    alert('Erro ao gerar BibTeX: ' + error.message);
  }
}

// Mostrar diálogo de confirmação BibTeX
function showBibTeXConfirmDialog(data) {
  const dialog = document.createElement('div');
  dialog.className = 'bibtex-dialog-overlay';
  dialog.innerHTML = `
    <div class="bibtex-dialog">
      <div class="bibtex-dialog-header">
        <h3>✅ BibTeX Gerado</h3>
        <button class="bibtex-dialog-close" onclick="this.closest('.bibtex-dialog-overlay').remove()">×</button>
      </div>
      
      <div class="bibtex-dialog-body">
        <div class="bibtex-info">
          <p><strong>Key:</strong> <code>${data.key}</code></p>
          <p><strong>Tipo:</strong> ${data.entry_type}</p>
          ${data.has_conflict ? '<p class="bibtex-warning">⚠️ Key já existe no .bib!</p>' : ''}
        </div>
        
        <div class="bibtex-preview">
          <pre><code>${data.bibtex}</code></pre>
        </div>
        
        <div class="bibtex-actions">
          <button class="btn btn-primary" onclick="insertCitation('${data.key}')">
            📝 Inserir \\cite{${data.key}}
          </button>
          <button class="btn btn-success" onclick="saveToBib(\`${data.bibtex.replace(/`/g, '\\`')}\`)">
            💾 Salvar no .bib
          </button>
          <button class="btn btn-secondary" onclick="this.closest('.bibtex-dialog-overlay').remove()">
            ❌ Cancelar
          </button>
        </div>
      </div>
    </div>
  `;
  
  document.body.appendChild(dialog);
}

// Inserir \cite{} no editor
function insertCitation(key) {
  const editor = window.latexEditor.editor;
  const citation = `\\cite{${key}}`;
  const pos = editor.selectionStart;
  const value = editor.value;
  editor.value = value.substring(0, pos) + citation + value.substring(pos);
  editor.selectionStart = editor.selectionEnd = pos + citation.length;
  window.latexEditor.updateLineNumbers();
  window.latexEditor.updateStatus();
  
  // Fechar diálogo
  document.querySelector('.bibtex-dialog-overlay')?.remove();
}

// Salvar no .bib
async function saveToBib(bibtexEntry) {
  try {
    const response = await fetch('/api/bib-file', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        bibtex_entry: bibtexEntry,
        mode: 'append'
      })
    });
    
    const data = await response.json();
    
    if (data.success) {
      alert('✅ Entrada adicionada ao .bib com sucesso!');
      // Fechar diálogo
      document.querySelector('.bibtex-dialog-overlay')?.remove();
    } else {
      alert('Erro ao salvar: ' + (data.error || 'Erro desconhecido'));
    }
  } catch (error) {
    alert('Erro ao salvar no .bib: ' + error.message);
  }
}

// Adicionar botão ao documento
// REMOVIDO: document.getElementById('assistantToggle').addEventListener('click', toggleAssistant);
</script>
-->
<!-- FIM DO CÓDIGO JAVASCRIPT DO ASSISTENTE (REMOVIDO) -->

<!-- ESTILOS DO ASSISTENTE (COMENTADOS) -->
<!--
<style>
/* Botão flutuante */
.assistant-toggle {
  position: fixed;
  bottom: 30px;
  right: 100px;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  font-size: 24px;
  cursor: pointer;
  box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
  transition: all 0.3s ease;
  z-index: 999;
}

.assistant-toggle:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
}

.assistant-toggle.active {
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

/* Painel do assistente */
.assistant-panel {
  position: fixed;
  right: -400px;
  top: 0;
  width: 400px;
  height: 100vh;
  background: white;
  box-shadow: -2px 0 20px rgba(0,0,0,0.1);
  transition: right 0.3s ease;
  z-index: 1000;
  display: flex;
  flex-direction: column;
}

.assistant-panel.open {
  right: 0;
}

/* Header */
.assistant-header {
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.assistant-header h3 {
  margin: 0;
  font-size: 18px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.assistant-close {
  background: none;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  opacity: 0.8;
  transition: opacity 0.2s;
}

.assistant-close:hover {
  opacity: 1;
}

/* Mensagens */
.assistant-messages {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  background: #f8f9fa;
}

.assistant-message {
  margin-bottom: 15px;
  animation: slideInMessage 0.3s ease;
}

@keyframes slideInMessage {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-content {
  padding: 12px 16px;
  border-radius: 12px;
  max-width: 85%;
}

.assistant-message.user .message-content {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  margin-left: auto;
  border-bottom-right-radius: 4px;
}

.assistant-message.assistant .message-content {
  background: white;
  color: #333;
  border: 1px solid #e0e0e0;
  border-bottom-left-radius: 4px;
}

.assistant-message.system .message-content {
  background: #e3f2fd;
  color: #1976d2;
  margin: 0 auto;
  text-align: center;
  font-size: 13px;
}

.assistant-message.system.error .message-content {
  background: #ffebee;
  color: #c62828;
}

.assistant-message.system.warning .message-content {
  background: #fff3e0;
  color: #e65100;
}

.assistant-message.action .message-content {
  background: #f3e5f5;
  color: #6a1b9a;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.message-content p {
  margin: 0;
  line-height: 1.5;
}

/* Badges de estado */
.action-badge {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transition: all 0.3s ease;
}

.action-badge.state-pending {
  background: #fff9c4;
  color: #f57f17;
}

.action-badge.state-applied_local {
  background: #e1f5fe;
  color: #0277bd;
  animation: pulse 1.5s infinite;
}

.action-badge.state-confirmed {
  background: #c8e6c9;
  color: #2e7d32;
}

.action-badge.state-reverted {
  background: #ffcdd2;
  color: #c62828;
}

.action-badge.state-error {
  background: #ffccbc;
  color: #bf360c;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

/* Input */
.assistant-input-wrapper {
  padding: 15px;
  background: white;
  border-top: 1px solid #e0e0e0;
  display: flex;
  gap: 10px;
}

.assistant-input {
  flex: 1;
  padding: 12px 16px;
  border: 1px solid #e0e0e0;
  border-radius: 24px;
  outline: none;
  font-size: 14px;
  transition: border-color 0.2s;
}

.assistant-input:focus {
  border-color: #667eea;
}

.assistant-send {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  cursor: pointer;
  transition: transform 0.2s;
}

.assistant-send:hover {
  transform: scale(1.1);
}
</style>
-->
<!-- FIM DO CÓDIGO DO ASSISTENTE LATEX (REMOVIDO) -->

<style>
/* ============================================================================ */
/* PAINEL DE LINT */
/* ============================================================================ */

.lint-toggle {
  position: fixed;
  bottom: 30px;
  right: 110px; /* Ao lado do botão de chat */
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
  font-size: 24px;
  z-index: 999;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.lint-toggle:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(240, 147, 251, 0.6);
}

.lint-toggle.has-errors {
  animation: shake 0.5s ease;
}

@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

.lint-badge {
  position: absolute;
  top: -5px;
  right: -5px;
  background: #dc3545;
  color: white;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: bold;
  animation: pulse 2s infinite;
}

.lint-panel {
  position: fixed;
  right: -450px;
  top: 80px;
  bottom: 20px;
  width: 420px;
  background: white;
  box-shadow: -2px 0 15px rgba(0,0,0,0.1);
  border-radius: 15px 0 0 15px;
  z-index: 998;
  display: flex;
  flex-direction: column;
  transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.lint-panel.open {
  right: 0;
}

.lint-header {
  padding: 20px;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border-radius: 15px 0 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.lint-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.lint-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: white;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  transition: background 0.2s;
}

.lint-close:hover {
  background: rgba(255,255,255,0.3);
}

.lint-summary {
  padding: 15px 20px;
  background: #f5f5f5;
  border-bottom: 1px solid #e0e0e0;
}

.lint-stats {
  display: flex;
  gap: 15px;
  margin-top: 10px;
}

.lint-stat {
  flex: 1;
  text-align: center;
  padding: 8px;
  background: white;
  border-radius: 8px;
  font-size: 12px;
}

.lint-stat-value {
  font-size: 20px;
  font-weight: bold;
  margin-bottom: 4px;
}

.lint-stat.errors .lint-stat-value {
  color: #d32f2f;
}

.lint-stat.warnings .lint-stat-value {
  color: #f57c00;
}

.lint-stat.suggestions .lint-stat-value {
  color: #1976d2;
}

.lint-issues {
  flex: 1;
  overflow-y: auto;
  padding: 10px 20px;
}

.lint-issue {
  background: white;
  border: 1px solid #e0e0e0;
  border-left: 4px solid #bdbdbd;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
}

.lint-issue:hover {
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  transform: translateX(-2px);
}

.lint-issue.severity-error {
  border-left-color: #d32f2f;
}

.lint-issue.severity-warning {
  border-left-color: #f57c00;
}

.lint-issue.severity-suggestion {
  border-left-color: #1976d2;
}

.lint-issue-header {
  display: flex;
  justify-content: space-between;
  align-items: start;
  margin-bottom: 8px;
}

.lint-issue-title {
  font-weight: 600;
  font-size: 14px;
  color: #333;
}

.lint-issue-location {
  font-size: 11px;
  color: #757575;
  background: #f5f5f5;
  padding: 3px 8px;
  border-radius: 12px;
}

.lint-issue-message {
  font-size: 13px;
  color: #616161;
  margin-bottom: 8px;
}

.lint-issue-suggestion {
  font-size: 12px;
  color: #1976d2;
  background: #e3f2fd;
  padding: 8px;
  border-radius: 6px;
  margin-top: 8px;
}

.lint-issue-actions {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.lint-fix-btn {
  flex: 1;
  padding: 6px 12px;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.lint-fix-btn.auto-fix {
  background: #4caf50;
  color: white;
}

.lint-fix-btn.auto-fix:hover {
  background: #388e3c;
}

.lint-fix-btn.go-to-line {
  background: #e0e0e0;
  color: #333;
}

.lint-fix-btn.go-to-line:hover {
  background: #bdbdbd;
}

.lint-footer {
  padding: 15px 20px;
  border-top: 1px solid #e0e0e0;
  background: white;
}

.lint-run-btn {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.lint-run-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(240, 147, 251, 0.4);
}

.lint-fix-all-btn {
  width: 100%;
  padding: 12px;
  background: #4caf50;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  margin-top: 10px;
}

.lint-fix-all-btn:hover {
  background: #388e3c;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.lint-fix-all-btn:disabled {
  background: #bdbdbd;
  cursor: not-allowed;
  transform: none;
}

/* ============================================================================ */
/* DIÁLOGO BIBTEX */
/* ============================================================================ */

.bibtex-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  animation: fadeIn 0.2s;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.bibtex-dialog {
  background: white;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.3);
  width: 90%;
  max-width: 700px;
  max-height: 80vh;
  overflow: hidden;
  animation: slideUp 0.3s;
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.bibtex-dialog-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.bibtex-dialog-header h3 {
  margin: 0;
  font-size: 20px;
}

.bibtex-dialog-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: white;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 24px;
  line-height: 1;
  transition: background 0.2s;
}

.bibtex-dialog-close:hover {
  background: rgba(255,255,255,0.3);
}

.bibtex-dialog-body {
  padding: 24px;
  max-height: calc(80vh - 80px);
  overflow-y: auto;
}

.bibtex-info {
  background: #f5f5f5;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 20px;
}

.bibtex-info p {
  margin: 8px 0;
}

.bibtex-info code {
  background: #e0e0e0;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  color: #d32f2f;
  font-weight: bold;
}

.bibtex-warning {
  color: #f57c00;
  font-weight: 600;
  margin-top: 12px;
}

.bibtex-preview {
  background: #263238;
  color: #aed581;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 20px;
  overflow-x: auto;
}

.bibtex-preview pre {
  margin: 0;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  line-height: 1.5;
}

.bibtex-preview code {
  color: #aed581;
}

.bibtex-actions {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.bibtex-actions .btn {
  flex: 1;
  min-width: 150px;
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.bibtex-actions .btn-primary {
  background: #2196f3;
  color: white;
}

.bibtex-actions .btn-primary:hover {
  background: #1976d2;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
}

.bibtex-actions .btn-success {
  background: #4caf50;
  color: white;
}

.bibtex-actions .btn-success:hover {
  background: #388e3c;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

.bibtex-actions .btn-secondary {
  background: #757575;
  color: white;
}

.bibtex-actions .btn-secondary:hover {
  background: #616161;
}
</style>

<!-- ============================================================================ -->
<!-- PAINEL DE LINT -->
<!-- ============================================================================ -->

<!-- Botão para abrir/fechar lint -->
<button id="lintToggle" class="lint-toggle" title="LaTeX Linter - Clique para abrir" onclick="toggleLint()">
  <i class="fas fa-check-circle"></i>
  <span id="lintBadge" class="lint-badge" style="display: none;">0</span>
</button>

<!-- Painel do linter -->
<div id="lintPanel" class="lint-panel">
  <div class="lint-header">
    <h3><i class="fas fa-check-circle"></i> LaTeX Linter</h3>
    <button class="lint-close" onclick="toggleLint()">
      <i class="fas fa-times"></i>
    </button>
  </div>
  
  <div class="lint-summary">
    <div>Status: <span id="lintStatus">Pronto</span></div>
    <div id="lintOutdatedWarning" style="display: none; color: #ff9800; font-size: 0.9rem; margin-top: 0.5rem;">
      ⚠️ Documento modificado. Clique em "Re-analisar" para atualizar.
    </div>
    <div class="lint-stats">
      <div class="lint-stat errors">
        <div class="lint-stat-value" id="lintErrors">0</div>
        <div>Erros</div>
      </div>
      <div class="lint-stat warnings">
        <div class="lint-stat-value" id="lintWarnings">0</div>
        <div>Avisos</div>
      </div>
      <div class="lint-stat suggestions">
        <div class="lint-stat-value" id="lintSuggestions">0</div>
        <div>Sugestões</div>
      </div>
    </div>
  </div>
  
  <div class="lint-issues" id="lintIssues">
    <p style="text-align: center; color: #757575; margin-top: 50px;">
      Clique em "Executar Lint" para analisar o documento
    </p>
  </div>
  
  <div class="lint-footer">
    <button class="lint-run-btn" onclick="runLint()">
      <i class="fas fa-sync-alt"></i> Re-analisar Documento
    </button>
    <button class="lint-fix-all-btn" id="lintFixAllBtn" onclick="applyAllFixes()" disabled>
      <i class="fas fa-magic"></i> Aplicar Todas as Correções
    </button>
  </div>
</div>

<script>
// Gerenciador de Lint
class LintManager {
  constructor() {
    this.currentIssues = [];
    this.currentFixes = [];
    this.lastLintedContent = '';
    this.setupDocumentChangeDetection();
  }
  
  setupDocumentChangeDetection() {
    // Detectar mudanças no documento
    if (window.latexEditor && window.latexEditor.editor) {
      window.latexEditor.editor.addEventListener('input', () => {
        if (this.lastLintedContent && this.lastLintedContent !== window.latexEditor.editor.value) {
          document.getElementById('lintOutdatedWarning').style.display = 'block';
        }
      });
    }
  }
  
  async runLint(content) {
    try {
      document.getElementById('lintStatus').textContent = 'Analisando...';
      document.getElementById('lintOutdatedWarning').style.display = 'none';
      
      const response = await fetch('/api/lint', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          content: content,
          filename: fileName || 'main.tex'
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        this.currentIssues = data.issues;
        this.currentFixes = data.fixes;
        this.lastLintedContent = content;
        this.displayResults(data);
        document.getElementById('lintStatus').textContent = `Completo: ${data.summary.total} issues`;
      } else {
        document.getElementById('lintStatus').textContent = 'Erro';
        console.error('Erro no lint:', data.error);
      }
    } catch (error) {
      document.getElementById('lintStatus').textContent = 'Erro';
      console.error('Erro ao executar lint:', error);
    }
  }
  
  displayResults(data) {
    const { summary, issues } = data;
    
    // Atualizar estatísticas
    document.getElementById('lintErrors').textContent = summary.errors;
    document.getElementById('lintWarnings').textContent = summary.warnings;
    document.getElementById('lintSuggestions').textContent = summary.suggestions;
    
    // Exibir issues
    const issuesContainer = document.getElementById('lintIssues');
    issuesContainer.innerHTML = '';
    
    if (issues.length === 0) {
      issuesContainer.innerHTML = '<p style="text-align: center; color: #4caf50; margin-top: 50px;"><i class="fas fa-check-circle"></i> Nenhum problema encontrado!</p>';
      document.getElementById('lintFixAllBtn').disabled = true;
      return;
    }
    
    issues.forEach(issue => {
      const issueEl = this.createIssueElement(issue);
      issuesContainer.appendChild(issueEl);
    });
    
    // Habilitar botão de fix all se houver fixes disponíveis
    document.getElementById('lintFixAllBtn').disabled = summary.auto_fixable === 0;
  }
  
  createIssueElement(issue) {
    const div = document.createElement('div');
    div.className = `lint-issue severity-${issue.severity}`;
    
    const header = `
      <div class="lint-issue-header">
        <div class="lint-issue-title">${issue.message}</div>
        <div class="lint-issue-location">Linha ${issue.line}</div>
      </div>
    `;
    
    const suggestion = issue.suggestion ? `
      <div class="lint-issue-suggestion">
        💡 ${issue.suggestion}
      </div>
    ` : '';
    
    const actions = `
      <div class="lint-issue-actions">
        ${issue.auto_fix ? '<button class="lint-fix-btn auto-fix" onclick="lintManager.applyFix(\'' + issue.rule_id + '_' + issue.line + '\')"><i class="fas fa-magic"></i> Corrigir</button>' : ''}
        <button class="lint-fix-btn go-to-line" onclick="lintManager.goToLine(${issue.line})"><i class="fas fa-arrow-right"></i> Ir para linha</button>
      </div>
    `;
    
    div.innerHTML = header + suggestion + actions;
    return div;
  }
  
  goToLine(lineNumber) {
    if (window.latexEditor && window.latexEditor.goToLine) {
      window.latexEditor.goToLine(lineNumber);
      // Fechar painel de lint
      toggleLint();
    }
  }
  
  async applyFix(fixId) {
    const fix = this.currentFixes.find(f => f.issue_id === fixId);
    if (!fix) {
      console.error('Fix não encontrado:', fixId);
      return;
    }
    
    try {
      const response = await fetch('/api/lint/auto-fix', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          content: window.latexEditor.editor.value,
          fix_ids: [fixId]
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        window.latexEditor.editor.value = data.modified_content;
        window.latexEditor.updateLineNumbers();
        window.latexEditor.updateStatus();
        // Re-executar lint
        await this.runLint(data.modified_content);
      } else {
        console.error('Erro ao aplicar fix:', data.error);
      }
    } catch (error) {
      console.error('Erro ao aplicar fix:', error);
    }
  }
  
  async applyAllFixes() {
    const autoFixableIds = this.currentFixes.map(f => f.issue_id);
    
    if (autoFixableIds.length === 0) {
      return;
    }
    
    try {
      const response = await fetch('/api/lint/auto-fix', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          content: window.latexEditor.editor.value,
          fix_ids: autoFixableIds
        })
      });
      
      const data = await response.json();
      
      if (data.success) {
        window.latexEditor.editor.value = data.modified_content;
        window.latexEditor.updateLineNumbers();
        window.latexEditor.updateStatus();
        // Re-executar lint
        await this.runLint(data.modified_content);
      } else {
        console.error('Erro ao aplicar fixes:', data.error);
      }
    } catch (error) {
      console.error('Erro ao aplicar fixes:', error);
    }
  }
}

// DESABILITADO: Conflita com LaTeXLinterUI
// const lintManager = new LintManager();

function toggleLint() {
  const panel = document.getElementById('lintPanel');
  const toggle = document.getElementById('lintToggle');
  panel.classList.toggle('open');
  toggle.classList.toggle('active');
}

function runLint() {
  // Tentar inicializar se ainda não foi
  if (!window.linterUI) {
    console.log('[Linter] Tentando inicializar...');
    if (!initializeLinterUI()) {
      console.error('LaTeXLinterUI não pode ser inicializado');
      alert('Erro: Editor não encontrado. Recarregue a página.');
      return;
    }
  }
  
  // Executar lint
  console.log('[Linter] Executando runLint...');
  window.linterUI.runLint();
}

function applyAllFixes() {
  if (window.linterUI && window.linterUI.applyAllFixes) {
    window.linterUI.applyAllFixes();
  } else {
    console.error('[Linter] UI não inicializado');
  }
}

// Botão do lintToggle já tem onclick no HTML

// ============================================================================
// FUNÇÕES DO MENU WINDOWS
// ============================================================================

// Menu Arquivo
function menuNewFile() {
  if (window.fileTree) {
    window.fileTree.showNewFileDialog();
  } else {
    newDocument();
  }
}

function menuNewFolder() {
  if (window.fileTree) {
    window.fileTree.showNewFolderDialog();
  } else {
    alert('Sistema de arquivos não disponível. Abra um projeto primeiro.');
  }
}

function menuOpenFile() {
  openDocument();
}

function menuSaveFile() {
  saveDocument();
}

function menuSaveAs() {
  // TODO: Implementar salvar como
  alert('Funcionalidade "Salvar Como" em desenvolvimento');
}

function menuUpload() {
  if (window.fileTree) {
    window.fileTree.showUploadDialog();
  } else {
    alert('Sistema de arquivos não disponível. Abra um projeto primeiro.');
  }
}

function menuDownloadZip() {
  if (window.fileTree) {
    window.fileTree.downloadProject();
  } else {
    alert('Sistema de arquivos não disponível. Abra um projeto primeiro.');
  }
}

// Menu Editar
function menuUndo() {
  undoAction();
}

function menuRedo() {
  redoAction();
}

function menuCut() {
  document.execCommand('cut');
}

function menuCopy() {
  document.execCommand('copy');
}

function menuPaste() {
  document.execCommand('paste');
}

function menuFind() {
  // Ctrl+F nativo do navegador
  const editor = document.getElementById('latexEditor');
  editor.focus();
  // Simular Ctrl+F
  alert('Use Ctrl+F para localizar no documento');
}

function menuReplace() {
  // Ctrl+H nativo do navegador
  alert('Use Ctrl+H para substituir no documento');
}

// Menu Ver
function menuToggleFileTree() {
  const sidebar = document.getElementById('fileTreeSidebar');
  sidebar.classList.toggle('collapsed');
}

function menuToggleSnippets() {
  const sidebar = document.getElementById('snippetsSidebar');
  sidebar.classList.toggle('collapsed');
}

function menuZoomIn() {
  const editor = document.getElementById('latexEditor');
  const currentSize = parseFloat(window.getComputedStyle(editor).fontSize);
  editor.style.fontSize = (currentSize + 1) + 'px';
}

function menuZoomOut() {
  const editor = document.getElementById('latexEditor');
  const currentSize = parseFloat(window.getComputedStyle(editor).fontSize);
  editor.style.fontSize = Math.max(10, currentSize - 1) + 'px';
}

function menuZoomReset() {
  const editor = document.getElementById('latexEditor');
  editor.style.fontSize = '14px';
}

// Menu Inserir
function menuInsertImage() {
  if (window.fileTree) {
    // Listar imagens do projeto
    const images = window.fileTree.files.filter(f => 
      ['png', 'jpg', 'jpeg', 'pdf', 'eps'].includes(f.type)
    );
    
    if (images.length === 0) {
      alert('Nenhuma imagem encontrada no projeto. Faça upload primeiro.');
      return;
    }
    
    // Criar seletor de imagens
    const imageName = prompt('Digite o nome da imagem:\n\n' + 
      images.map(img => `- ${img.name}`).join('\n'));
    
    if (imageName) {
      const snippet = `\\begin{figure}[h]\n  \\centering\n  \\includegraphics[width=0.8\\textwidth]{${imageName}}\n  \\caption{Legenda}\n  \\label{fig:${imageName.split('.')[0]}}\n\\end{figure}`;
      insertSnippet('custom', snippet);
    }
  } else {
    alert('Sistema de arquivos não disponível. Abra um projeto primeiro.');
  }
}

// Menu Ajuda
function menuShowHelp() {
  window.open('https://www.latex-project.org/help/documentation/', '_blank');
}

function menuShowShortcuts() {
  alert(`Atalhos de Teclado:

Arquivo:
  Ctrl+N - Novo Arquivo
  Ctrl+O - Abrir
  Ctrl+S - Salvar

Editar:
  Ctrl+Z - Desfazer
  Ctrl+Y - Refazer
  Ctrl+X - Recortar
  Ctrl+C - Copiar
  Ctrl+V - Colar
  Ctrl+F - Localizar
  Ctrl+H - Substituir

Ver:
  Ctrl+B - Árvore de Arquivos
  Ctrl++ - Aumentar Zoom
  Ctrl+- - Diminuir Zoom
  Ctrl+0 - Zoom Padrão

Ferramentas:
  F5 - Compilar
  F6 - Visualizar PDF

Ajuda:
  F1 - Ajuda do LaTeX`);
}

function menuAbout() {
  alert(`DocCollab - Editor LaTeX Colaborativo
Versão 1.0

Desenvolvido com:
- Flask (Backend)
- JavaScript (Frontend)
- LaTeX (Compilação)

© 2025 DocCollab`);
}

// Função auxiliar para inserir snippet customizado
function insertCustomSnippet(text) {
  const editor = window.latexEditor.editor;
  const start = editor.selectionStart;
  const end = editor.selectionEnd;
  const before = editor.value.substring(0, start);
  const after = editor.value.substring(end);
  editor.value = before + text + after;
  editor.selectionStart = editor.selectionEnd = start + text.length;
  editor.focus();
  window.latexEditor.updateLineNumbers();
  window.latexEditor.updateStatus();
}

</script>

<!-- ============================================================================ -->
<!-- GERENCIADOR DE ARQUIVOS -->
<!-- ============================================================================ -->

<link rel="stylesheet" href="{{ url_for('static', filename='css/file_tree.css') }}">
<script src="{{ url_for('static', filename='js/file_tree.js') }}"></script>

<script>
// Inicializar gerenciador de arquivos
const projectId = {{ project.id if project else 0 }};

if (projectId > 0) {
  const fileTree = new FileTreeManager(projectId, 'fileTreeSidebar');
  
  // Callback quando arquivo é selecionado
  fileTree.onFileSelect = async (file) => {
    console.log('Arquivo selecionado:', file);
    
    // Carregar conteúdo do arquivo no editor
    try {
      const response = await fetch(`/api/project/${projectId}/file/${file.id}`);
      const data = await response.json();
      
      if (data.success && data.file.content) {
        window.latexEditor.editor.value = data.file.content;
        window.latexEditor.updateLineNumbers();
        window.latexEditor.updateStatus();
        
        // Atualizar nome do arquivo na toolbar
        document.getElementById('fileName').textContent = file.name;
      }
    } catch (error) {
      console.error('Erro ao carregar arquivo:', error);
    }
  };
  
  // Callback quando arquivo é criado
  fileTree.onFileCreate = (file) => {
    console.log('Arquivo criado:', file);
    // Selecionar o novo arquivo
    fileTree.selectFile(file.id);
  };
  
  // Callback quando pasta é criada
  fileTree.onFolderCreate = (folder) => {
    console.log('Pasta criada:', folder);
  };
  
  // Expor globalmente para uso em outras funções
  window.fileTree = fileTree;
}

// Função global para fechar modal de PDF
function closePDFModal() {
  const modal = document.getElementById('pdfModal');
  if (modal) {
    modal.classList.remove('active');
    // Limpar iframe para economizar memória
    setTimeout(() => {
      const iframe = document.getElementById('pdfIframe');
      if (iframe) iframe.src = '';
    }, 300);
  }
}

function downloadPDFFromModal() {
  if (!window.currentPdfUrl) {
    alert('Nenhum PDF disponível para download');
    return;
  }
  
  // Criar link temporário para download
  const link = document.createElement('a');
  link.href = window.currentPdfUrl;
  link.download = window.currentPdfFilename || 'documento.pdf';
  link.style.display = 'none';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Mostrar notificação de sucesso
  if (window.latexEditor) {
    window.latexEditor.showNotification('PDF baixado com sucesso!', 'success');
  }
}

function printPDFFromModal() {
  if (!window.currentPdfUrl) {
    alert('Nenhum PDF disponível para impressão');
    return;
  }
  
  // Tentar imprimir o PDF do iframe
  const iframe = document.getElementById('pdfIframe');
  if (iframe && iframe.contentWindow) {
    try {
      iframe.contentWindow.print();
    } catch (e) {
      // Se falhar, abrir em nova janela para imprimir
      window.open(window.currentPdfUrl, '_blank');
    }
  } else {
    window.open(window.currentPdfUrl, '_blank');
  }
}
</script>

{% endblock %}